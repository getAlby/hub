// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	"github.com/getAlby/hub/lnclient"
	mock "github.com/stretchr/testify/mock"
)

// NewMockLNClient creates a new instance of MockLNClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLNClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLNClient {
	mock := &MockLNClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockLNClient is an autogenerated mock type for the LNClient type
type MockLNClient struct {
	mock.Mock
}

type MockLNClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLNClient) EXPECT() *MockLNClient_Expecter {
	return &MockLNClient_Expecter{mock: &_m.Mock}
}

// CancelHoldInvoice provides a mock function for the type MockLNClient
func (_mock *MockLNClient) CancelHoldInvoice(ctx context.Context, paymentHash string) error {
	ret := _mock.Called(ctx, paymentHash)

	if len(ret) == 0 {
		panic("no return value specified for CancelHoldInvoice")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, paymentHash)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockLNClient_CancelHoldInvoice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelHoldInvoice'
type MockLNClient_CancelHoldInvoice_Call struct {
	*mock.Call
}

// CancelHoldInvoice is a helper method to define mock.On call
//   - ctx
//   - paymentHash
func (_e *MockLNClient_Expecter) CancelHoldInvoice(ctx interface{}, paymentHash interface{}) *MockLNClient_CancelHoldInvoice_Call {
	return &MockLNClient_CancelHoldInvoice_Call{Call: _e.mock.On("CancelHoldInvoice", ctx, paymentHash)}
}

func (_c *MockLNClient_CancelHoldInvoice_Call) Run(run func(ctx context.Context, paymentHash string)) *MockLNClient_CancelHoldInvoice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLNClient_CancelHoldInvoice_Call) Return(err error) *MockLNClient_CancelHoldInvoice_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockLNClient_CancelHoldInvoice_Call) RunAndReturn(run func(ctx context.Context, paymentHash string) error) *MockLNClient_CancelHoldInvoice_Call {
	_c.Call.Return(run)
	return _c
}

// CloseChannel provides a mock function for the type MockLNClient
func (_mock *MockLNClient) CloseChannel(ctx context.Context, closeChannelRequest *lnclient.CloseChannelRequest) (*lnclient.CloseChannelResponse, error) {
	ret := _mock.Called(ctx, closeChannelRequest)

	if len(ret) == 0 {
		panic("no return value specified for CloseChannel")
	}

	var r0 *lnclient.CloseChannelResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *lnclient.CloseChannelRequest) (*lnclient.CloseChannelResponse, error)); ok {
		return returnFunc(ctx, closeChannelRequest)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *lnclient.CloseChannelRequest) *lnclient.CloseChannelResponse); ok {
		r0 = returnFunc(ctx, closeChannelRequest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.CloseChannelResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *lnclient.CloseChannelRequest) error); ok {
		r1 = returnFunc(ctx, closeChannelRequest)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_CloseChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CloseChannel'
type MockLNClient_CloseChannel_Call struct {
	*mock.Call
}

// CloseChannel is a helper method to define mock.On call
//   - ctx
//   - closeChannelRequest
func (_e *MockLNClient_Expecter) CloseChannel(ctx interface{}, closeChannelRequest interface{}) *MockLNClient_CloseChannel_Call {
	return &MockLNClient_CloseChannel_Call{Call: _e.mock.On("CloseChannel", ctx, closeChannelRequest)}
}

func (_c *MockLNClient_CloseChannel_Call) Run(run func(ctx context.Context, closeChannelRequest *lnclient.CloseChannelRequest)) *MockLNClient_CloseChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*lnclient.CloseChannelRequest))
	})
	return _c
}

func (_c *MockLNClient_CloseChannel_Call) Return(closeChannelResponse *lnclient.CloseChannelResponse, err error) *MockLNClient_CloseChannel_Call {
	_c.Call.Return(closeChannelResponse, err)
	return _c
}

func (_c *MockLNClient_CloseChannel_Call) RunAndReturn(run func(ctx context.Context, closeChannelRequest *lnclient.CloseChannelRequest) (*lnclient.CloseChannelResponse, error)) *MockLNClient_CloseChannel_Call {
	_c.Call.Return(run)
	return _c
}

// ConnectPeer provides a mock function for the type MockLNClient
func (_mock *MockLNClient) ConnectPeer(ctx context.Context, connectPeerRequest *lnclient.ConnectPeerRequest) error {
	ret := _mock.Called(ctx, connectPeerRequest)

	if len(ret) == 0 {
		panic("no return value specified for ConnectPeer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *lnclient.ConnectPeerRequest) error); ok {
		r0 = returnFunc(ctx, connectPeerRequest)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockLNClient_ConnectPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConnectPeer'
type MockLNClient_ConnectPeer_Call struct {
	*mock.Call
}

// ConnectPeer is a helper method to define mock.On call
//   - ctx
//   - connectPeerRequest
func (_e *MockLNClient_Expecter) ConnectPeer(ctx interface{}, connectPeerRequest interface{}) *MockLNClient_ConnectPeer_Call {
	return &MockLNClient_ConnectPeer_Call{Call: _e.mock.On("ConnectPeer", ctx, connectPeerRequest)}
}

func (_c *MockLNClient_ConnectPeer_Call) Run(run func(ctx context.Context, connectPeerRequest *lnclient.ConnectPeerRequest)) *MockLNClient_ConnectPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*lnclient.ConnectPeerRequest))
	})
	return _c
}

func (_c *MockLNClient_ConnectPeer_Call) Return(err error) *MockLNClient_ConnectPeer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockLNClient_ConnectPeer_Call) RunAndReturn(run func(ctx context.Context, connectPeerRequest *lnclient.ConnectPeerRequest) error) *MockLNClient_ConnectPeer_Call {
	_c.Call.Return(run)
	return _c
}

// DisconnectPeer provides a mock function for the type MockLNClient
func (_mock *MockLNClient) DisconnectPeer(ctx context.Context, peerId string) error {
	ret := _mock.Called(ctx, peerId)

	if len(ret) == 0 {
		panic("no return value specified for DisconnectPeer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, peerId)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockLNClient_DisconnectPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisconnectPeer'
type MockLNClient_DisconnectPeer_Call struct {
	*mock.Call
}

// DisconnectPeer is a helper method to define mock.On call
//   - ctx
//   - peerId
func (_e *MockLNClient_Expecter) DisconnectPeer(ctx interface{}, peerId interface{}) *MockLNClient_DisconnectPeer_Call {
	return &MockLNClient_DisconnectPeer_Call{Call: _e.mock.On("DisconnectPeer", ctx, peerId)}
}

func (_c *MockLNClient_DisconnectPeer_Call) Run(run func(ctx context.Context, peerId string)) *MockLNClient_DisconnectPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLNClient_DisconnectPeer_Call) Return(err error) *MockLNClient_DisconnectPeer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockLNClient_DisconnectPeer_Call) RunAndReturn(run func(ctx context.Context, peerId string) error) *MockLNClient_DisconnectPeer_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteCustomNodeCommand provides a mock function for the type MockLNClient
func (_mock *MockLNClient) ExecuteCustomNodeCommand(ctx context.Context, command *lnclient.CustomNodeCommandRequest) (*lnclient.CustomNodeCommandResponse, error) {
	ret := _mock.Called(ctx, command)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteCustomNodeCommand")
	}

	var r0 *lnclient.CustomNodeCommandResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *lnclient.CustomNodeCommandRequest) (*lnclient.CustomNodeCommandResponse, error)); ok {
		return returnFunc(ctx, command)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *lnclient.CustomNodeCommandRequest) *lnclient.CustomNodeCommandResponse); ok {
		r0 = returnFunc(ctx, command)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.CustomNodeCommandResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *lnclient.CustomNodeCommandRequest) error); ok {
		r1 = returnFunc(ctx, command)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_ExecuteCustomNodeCommand_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteCustomNodeCommand'
type MockLNClient_ExecuteCustomNodeCommand_Call struct {
	*mock.Call
}

// ExecuteCustomNodeCommand is a helper method to define mock.On call
//   - ctx
//   - command
func (_e *MockLNClient_Expecter) ExecuteCustomNodeCommand(ctx interface{}, command interface{}) *MockLNClient_ExecuteCustomNodeCommand_Call {
	return &MockLNClient_ExecuteCustomNodeCommand_Call{Call: _e.mock.On("ExecuteCustomNodeCommand", ctx, command)}
}

func (_c *MockLNClient_ExecuteCustomNodeCommand_Call) Run(run func(ctx context.Context, command *lnclient.CustomNodeCommandRequest)) *MockLNClient_ExecuteCustomNodeCommand_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*lnclient.CustomNodeCommandRequest))
	})
	return _c
}

func (_c *MockLNClient_ExecuteCustomNodeCommand_Call) Return(customNodeCommandResponse *lnclient.CustomNodeCommandResponse, err error) *MockLNClient_ExecuteCustomNodeCommand_Call {
	_c.Call.Return(customNodeCommandResponse, err)
	return _c
}

func (_c *MockLNClient_ExecuteCustomNodeCommand_Call) RunAndReturn(run func(ctx context.Context, command *lnclient.CustomNodeCommandRequest) (*lnclient.CustomNodeCommandResponse, error)) *MockLNClient_ExecuteCustomNodeCommand_Call {
	_c.Call.Return(run)
	return _c
}

// GetBalances provides a mock function for the type MockLNClient
func (_mock *MockLNClient) GetBalances(ctx context.Context, includeInactiveChannels bool) (*lnclient.BalancesResponse, error) {
	ret := _mock.Called(ctx, includeInactiveChannels)

	if len(ret) == 0 {
		panic("no return value specified for GetBalances")
	}

	var r0 *lnclient.BalancesResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, bool) (*lnclient.BalancesResponse, error)); ok {
		return returnFunc(ctx, includeInactiveChannels)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, bool) *lnclient.BalancesResponse); ok {
		r0 = returnFunc(ctx, includeInactiveChannels)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.BalancesResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, bool) error); ok {
		r1 = returnFunc(ctx, includeInactiveChannels)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_GetBalances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBalances'
type MockLNClient_GetBalances_Call struct {
	*mock.Call
}

// GetBalances is a helper method to define mock.On call
//   - ctx
//   - includeInactiveChannels
func (_e *MockLNClient_Expecter) GetBalances(ctx interface{}, includeInactiveChannels interface{}) *MockLNClient_GetBalances_Call {
	return &MockLNClient_GetBalances_Call{Call: _e.mock.On("GetBalances", ctx, includeInactiveChannels)}
}

func (_c *MockLNClient_GetBalances_Call) Run(run func(ctx context.Context, includeInactiveChannels bool)) *MockLNClient_GetBalances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(bool))
	})
	return _c
}

func (_c *MockLNClient_GetBalances_Call) Return(balancesResponse *lnclient.BalancesResponse, err error) *MockLNClient_GetBalances_Call {
	_c.Call.Return(balancesResponse, err)
	return _c
}

func (_c *MockLNClient_GetBalances_Call) RunAndReturn(run func(ctx context.Context, includeInactiveChannels bool) (*lnclient.BalancesResponse, error)) *MockLNClient_GetBalances_Call {
	_c.Call.Return(run)
	return _c
}

// GetCustomNodeCommandDefinitions provides a mock function for the type MockLNClient
func (_mock *MockLNClient) GetCustomNodeCommandDefinitions() []lnclient.CustomNodeCommandDef {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetCustomNodeCommandDefinitions")
	}

	var r0 []lnclient.CustomNodeCommandDef
	if returnFunc, ok := ret.Get(0).(func() []lnclient.CustomNodeCommandDef); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]lnclient.CustomNodeCommandDef)
		}
	}
	return r0
}

// MockLNClient_GetCustomNodeCommandDefinitions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCustomNodeCommandDefinitions'
type MockLNClient_GetCustomNodeCommandDefinitions_Call struct {
	*mock.Call
}

// GetCustomNodeCommandDefinitions is a helper method to define mock.On call
func (_e *MockLNClient_Expecter) GetCustomNodeCommandDefinitions() *MockLNClient_GetCustomNodeCommandDefinitions_Call {
	return &MockLNClient_GetCustomNodeCommandDefinitions_Call{Call: _e.mock.On("GetCustomNodeCommandDefinitions")}
}

func (_c *MockLNClient_GetCustomNodeCommandDefinitions_Call) Run(run func()) *MockLNClient_GetCustomNodeCommandDefinitions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLNClient_GetCustomNodeCommandDefinitions_Call) Return(customNodeCommandDefs []lnclient.CustomNodeCommandDef) *MockLNClient_GetCustomNodeCommandDefinitions_Call {
	_c.Call.Return(customNodeCommandDefs)
	return _c
}

func (_c *MockLNClient_GetCustomNodeCommandDefinitions_Call) RunAndReturn(run func() []lnclient.CustomNodeCommandDef) *MockLNClient_GetCustomNodeCommandDefinitions_Call {
	_c.Call.Return(run)
	return _c
}

// GetInfo provides a mock function for the type MockLNClient
func (_mock *MockLNClient) GetInfo(ctx context.Context) (*lnclient.NodeInfo, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetInfo")
	}

	var r0 *lnclient.NodeInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*lnclient.NodeInfo, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *lnclient.NodeInfo); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.NodeInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_GetInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInfo'
type MockLNClient_GetInfo_Call struct {
	*mock.Call
}

// GetInfo is a helper method to define mock.On call
//   - ctx
func (_e *MockLNClient_Expecter) GetInfo(ctx interface{}) *MockLNClient_GetInfo_Call {
	return &MockLNClient_GetInfo_Call{Call: _e.mock.On("GetInfo", ctx)}
}

func (_c *MockLNClient_GetInfo_Call) Run(run func(ctx context.Context)) *MockLNClient_GetInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLNClient_GetInfo_Call) Return(info *lnclient.NodeInfo, err error) *MockLNClient_GetInfo_Call {
	_c.Call.Return(info, err)
	return _c
}

func (_c *MockLNClient_GetInfo_Call) RunAndReturn(run func(ctx context.Context) (*lnclient.NodeInfo, error)) *MockLNClient_GetInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogOutput provides a mock function for the type MockLNClient
func (_mock *MockLNClient) GetLogOutput(ctx context.Context, maxLen int) ([]byte, error) {
	ret := _mock.Called(ctx, maxLen)

	if len(ret) == 0 {
		panic("no return value specified for GetLogOutput")
	}

	var r0 []byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) ([]byte, error)); ok {
		return returnFunc(ctx, maxLen)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) []byte); ok {
		r0 = returnFunc(ctx, maxLen)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = returnFunc(ctx, maxLen)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_GetLogOutput_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogOutput'
type MockLNClient_GetLogOutput_Call struct {
	*mock.Call
}

// GetLogOutput is a helper method to define mock.On call
//   - ctx
//   - maxLen
func (_e *MockLNClient_Expecter) GetLogOutput(ctx interface{}, maxLen interface{}) *MockLNClient_GetLogOutput_Call {
	return &MockLNClient_GetLogOutput_Call{Call: _e.mock.On("GetLogOutput", ctx, maxLen)}
}

func (_c *MockLNClient_GetLogOutput_Call) Run(run func(ctx context.Context, maxLen int)) *MockLNClient_GetLogOutput_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockLNClient_GetLogOutput_Call) Return(bytes []byte, err error) *MockLNClient_GetLogOutput_Call {
	_c.Call.Return(bytes, err)
	return _c
}

func (_c *MockLNClient_GetLogOutput_Call) RunAndReturn(run func(ctx context.Context, maxLen int) ([]byte, error)) *MockLNClient_GetLogOutput_Call {
	_c.Call.Return(run)
	return _c
}

// GetNetworkGraph provides a mock function for the type MockLNClient
func (_mock *MockLNClient) GetNetworkGraph(ctx context.Context, nodeIds []string) (lnclient.NetworkGraphResponse, error) {
	ret := _mock.Called(ctx, nodeIds)

	if len(ret) == 0 {
		panic("no return value specified for GetNetworkGraph")
	}

	var r0 lnclient.NetworkGraphResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string) (lnclient.NetworkGraphResponse, error)); ok {
		return returnFunc(ctx, nodeIds)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string) lnclient.NetworkGraphResponse); ok {
		r0 = returnFunc(ctx, nodeIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(lnclient.NetworkGraphResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = returnFunc(ctx, nodeIds)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_GetNetworkGraph_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNetworkGraph'
type MockLNClient_GetNetworkGraph_Call struct {
	*mock.Call
}

// GetNetworkGraph is a helper method to define mock.On call
//   - ctx
//   - nodeIds
func (_e *MockLNClient_Expecter) GetNetworkGraph(ctx interface{}, nodeIds interface{}) *MockLNClient_GetNetworkGraph_Call {
	return &MockLNClient_GetNetworkGraph_Call{Call: _e.mock.On("GetNetworkGraph", ctx, nodeIds)}
}

func (_c *MockLNClient_GetNetworkGraph_Call) Run(run func(ctx context.Context, nodeIds []string)) *MockLNClient_GetNetworkGraph_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockLNClient_GetNetworkGraph_Call) Return(v lnclient.NetworkGraphResponse, err error) *MockLNClient_GetNetworkGraph_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockLNClient_GetNetworkGraph_Call) RunAndReturn(run func(ctx context.Context, nodeIds []string) (lnclient.NetworkGraphResponse, error)) *MockLNClient_GetNetworkGraph_Call {
	_c.Call.Return(run)
	return _c
}

// GetNewOnchainAddress provides a mock function for the type MockLNClient
func (_mock *MockLNClient) GetNewOnchainAddress(ctx context.Context) (string, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetNewOnchainAddress")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_GetNewOnchainAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNewOnchainAddress'
type MockLNClient_GetNewOnchainAddress_Call struct {
	*mock.Call
}

// GetNewOnchainAddress is a helper method to define mock.On call
//   - ctx
func (_e *MockLNClient_Expecter) GetNewOnchainAddress(ctx interface{}) *MockLNClient_GetNewOnchainAddress_Call {
	return &MockLNClient_GetNewOnchainAddress_Call{Call: _e.mock.On("GetNewOnchainAddress", ctx)}
}

func (_c *MockLNClient_GetNewOnchainAddress_Call) Run(run func(ctx context.Context)) *MockLNClient_GetNewOnchainAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLNClient_GetNewOnchainAddress_Call) Return(s string, err error) *MockLNClient_GetNewOnchainAddress_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockLNClient_GetNewOnchainAddress_Call) RunAndReturn(run func(ctx context.Context) (string, error)) *MockLNClient_GetNewOnchainAddress_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodeConnectionInfo provides a mock function for the type MockLNClient
func (_mock *MockLNClient) GetNodeConnectionInfo(ctx context.Context) (*lnclient.NodeConnectionInfo, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetNodeConnectionInfo")
	}

	var r0 *lnclient.NodeConnectionInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*lnclient.NodeConnectionInfo, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *lnclient.NodeConnectionInfo); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.NodeConnectionInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_GetNodeConnectionInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodeConnectionInfo'
type MockLNClient_GetNodeConnectionInfo_Call struct {
	*mock.Call
}

// GetNodeConnectionInfo is a helper method to define mock.On call
//   - ctx
func (_e *MockLNClient_Expecter) GetNodeConnectionInfo(ctx interface{}) *MockLNClient_GetNodeConnectionInfo_Call {
	return &MockLNClient_GetNodeConnectionInfo_Call{Call: _e.mock.On("GetNodeConnectionInfo", ctx)}
}

func (_c *MockLNClient_GetNodeConnectionInfo_Call) Run(run func(ctx context.Context)) *MockLNClient_GetNodeConnectionInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLNClient_GetNodeConnectionInfo_Call) Return(nodeConnectionInfo *lnclient.NodeConnectionInfo, err error) *MockLNClient_GetNodeConnectionInfo_Call {
	_c.Call.Return(nodeConnectionInfo, err)
	return _c
}

func (_c *MockLNClient_GetNodeConnectionInfo_Call) RunAndReturn(run func(ctx context.Context) (*lnclient.NodeConnectionInfo, error)) *MockLNClient_GetNodeConnectionInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodeStatus provides a mock function for the type MockLNClient
func (_mock *MockLNClient) GetNodeStatus(ctx context.Context) (*lnclient.NodeStatus, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetNodeStatus")
	}

	var r0 *lnclient.NodeStatus
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*lnclient.NodeStatus, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *lnclient.NodeStatus); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.NodeStatus)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_GetNodeStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodeStatus'
type MockLNClient_GetNodeStatus_Call struct {
	*mock.Call
}

// GetNodeStatus is a helper method to define mock.On call
//   - ctx
func (_e *MockLNClient_Expecter) GetNodeStatus(ctx interface{}) *MockLNClient_GetNodeStatus_Call {
	return &MockLNClient_GetNodeStatus_Call{Call: _e.mock.On("GetNodeStatus", ctx)}
}

func (_c *MockLNClient_GetNodeStatus_Call) Run(run func(ctx context.Context)) *MockLNClient_GetNodeStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLNClient_GetNodeStatus_Call) Return(nodeStatus *lnclient.NodeStatus, err error) *MockLNClient_GetNodeStatus_Call {
	_c.Call.Return(nodeStatus, err)
	return _c
}

func (_c *MockLNClient_GetNodeStatus_Call) RunAndReturn(run func(ctx context.Context) (*lnclient.NodeStatus, error)) *MockLNClient_GetNodeStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetOnchainBalance provides a mock function for the type MockLNClient
func (_mock *MockLNClient) GetOnchainBalance(ctx context.Context) (*lnclient.OnchainBalanceResponse, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetOnchainBalance")
	}

	var r0 *lnclient.OnchainBalanceResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*lnclient.OnchainBalanceResponse, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *lnclient.OnchainBalanceResponse); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.OnchainBalanceResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_GetOnchainBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOnchainBalance'
type MockLNClient_GetOnchainBalance_Call struct {
	*mock.Call
}

// GetOnchainBalance is a helper method to define mock.On call
//   - ctx
func (_e *MockLNClient_Expecter) GetOnchainBalance(ctx interface{}) *MockLNClient_GetOnchainBalance_Call {
	return &MockLNClient_GetOnchainBalance_Call{Call: _e.mock.On("GetOnchainBalance", ctx)}
}

func (_c *MockLNClient_GetOnchainBalance_Call) Run(run func(ctx context.Context)) *MockLNClient_GetOnchainBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLNClient_GetOnchainBalance_Call) Return(onchainBalanceResponse *lnclient.OnchainBalanceResponse, err error) *MockLNClient_GetOnchainBalance_Call {
	_c.Call.Return(onchainBalanceResponse, err)
	return _c
}

func (_c *MockLNClient_GetOnchainBalance_Call) RunAndReturn(run func(ctx context.Context) (*lnclient.OnchainBalanceResponse, error)) *MockLNClient_GetOnchainBalance_Call {
	_c.Call.Return(run)
	return _c
}

// GetPubkey provides a mock function for the type MockLNClient
func (_mock *MockLNClient) GetPubkey() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetPubkey")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockLNClient_GetPubkey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPubkey'
type MockLNClient_GetPubkey_Call struct {
	*mock.Call
}

// GetPubkey is a helper method to define mock.On call
func (_e *MockLNClient_Expecter) GetPubkey() *MockLNClient_GetPubkey_Call {
	return &MockLNClient_GetPubkey_Call{Call: _e.mock.On("GetPubkey")}
}

func (_c *MockLNClient_GetPubkey_Call) Run(run func()) *MockLNClient_GetPubkey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLNClient_GetPubkey_Call) Return(s string) *MockLNClient_GetPubkey_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockLNClient_GetPubkey_Call) RunAndReturn(run func() string) *MockLNClient_GetPubkey_Call {
	_c.Call.Return(run)
	return _c
}

// GetStorageDir provides a mock function for the type MockLNClient
func (_mock *MockLNClient) GetStorageDir() (string, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetStorageDir")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (string, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_GetStorageDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStorageDir'
type MockLNClient_GetStorageDir_Call struct {
	*mock.Call
}

// GetStorageDir is a helper method to define mock.On call
func (_e *MockLNClient_Expecter) GetStorageDir() *MockLNClient_GetStorageDir_Call {
	return &MockLNClient_GetStorageDir_Call{Call: _e.mock.On("GetStorageDir")}
}

func (_c *MockLNClient_GetStorageDir_Call) Run(run func()) *MockLNClient_GetStorageDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLNClient_GetStorageDir_Call) Return(s string, err error) *MockLNClient_GetStorageDir_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockLNClient_GetStorageDir_Call) RunAndReturn(run func() (string, error)) *MockLNClient_GetStorageDir_Call {
	_c.Call.Return(run)
	return _c
}

// GetSupportedNIP47Methods provides a mock function for the type MockLNClient
func (_mock *MockLNClient) GetSupportedNIP47Methods() []string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSupportedNIP47Methods")
	}

	var r0 []string
	if returnFunc, ok := ret.Get(0).(func() []string); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	return r0
}

// MockLNClient_GetSupportedNIP47Methods_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSupportedNIP47Methods'
type MockLNClient_GetSupportedNIP47Methods_Call struct {
	*mock.Call
}

// GetSupportedNIP47Methods is a helper method to define mock.On call
func (_e *MockLNClient_Expecter) GetSupportedNIP47Methods() *MockLNClient_GetSupportedNIP47Methods_Call {
	return &MockLNClient_GetSupportedNIP47Methods_Call{Call: _e.mock.On("GetSupportedNIP47Methods")}
}

func (_c *MockLNClient_GetSupportedNIP47Methods_Call) Run(run func()) *MockLNClient_GetSupportedNIP47Methods_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLNClient_GetSupportedNIP47Methods_Call) Return(strings []string) *MockLNClient_GetSupportedNIP47Methods_Call {
	_c.Call.Return(strings)
	return _c
}

func (_c *MockLNClient_GetSupportedNIP47Methods_Call) RunAndReturn(run func() []string) *MockLNClient_GetSupportedNIP47Methods_Call {
	_c.Call.Return(run)
	return _c
}

// GetSupportedNIP47NotificationTypes provides a mock function for the type MockLNClient
func (_mock *MockLNClient) GetSupportedNIP47NotificationTypes() []string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSupportedNIP47NotificationTypes")
	}

	var r0 []string
	if returnFunc, ok := ret.Get(0).(func() []string); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	return r0
}

// MockLNClient_GetSupportedNIP47NotificationTypes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSupportedNIP47NotificationTypes'
type MockLNClient_GetSupportedNIP47NotificationTypes_Call struct {
	*mock.Call
}

// GetSupportedNIP47NotificationTypes is a helper method to define mock.On call
func (_e *MockLNClient_Expecter) GetSupportedNIP47NotificationTypes() *MockLNClient_GetSupportedNIP47NotificationTypes_Call {
	return &MockLNClient_GetSupportedNIP47NotificationTypes_Call{Call: _e.mock.On("GetSupportedNIP47NotificationTypes")}
}

func (_c *MockLNClient_GetSupportedNIP47NotificationTypes_Call) Run(run func()) *MockLNClient_GetSupportedNIP47NotificationTypes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLNClient_GetSupportedNIP47NotificationTypes_Call) Return(strings []string) *MockLNClient_GetSupportedNIP47NotificationTypes_Call {
	_c.Call.Return(strings)
	return _c
}

func (_c *MockLNClient_GetSupportedNIP47NotificationTypes_Call) RunAndReturn(run func() []string) *MockLNClient_GetSupportedNIP47NotificationTypes_Call {
	_c.Call.Return(run)
	return _c
}

// ListChannels provides a mock function for the type MockLNClient
func (_mock *MockLNClient) ListChannels(ctx context.Context) ([]lnclient.Channel, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListChannels")
	}

	var r0 []lnclient.Channel
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]lnclient.Channel, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []lnclient.Channel); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]lnclient.Channel)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_ListChannels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListChannels'
type MockLNClient_ListChannels_Call struct {
	*mock.Call
}

// ListChannels is a helper method to define mock.On call
//   - ctx
func (_e *MockLNClient_Expecter) ListChannels(ctx interface{}) *MockLNClient_ListChannels_Call {
	return &MockLNClient_ListChannels_Call{Call: _e.mock.On("ListChannels", ctx)}
}

func (_c *MockLNClient_ListChannels_Call) Run(run func(ctx context.Context)) *MockLNClient_ListChannels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLNClient_ListChannels_Call) Return(channels []lnclient.Channel, err error) *MockLNClient_ListChannels_Call {
	_c.Call.Return(channels, err)
	return _c
}

func (_c *MockLNClient_ListChannels_Call) RunAndReturn(run func(ctx context.Context) ([]lnclient.Channel, error)) *MockLNClient_ListChannels_Call {
	_c.Call.Return(run)
	return _c
}

// ListOnchainTransactions provides a mock function for the type MockLNClient
func (_mock *MockLNClient) ListOnchainTransactions(ctx context.Context) ([]lnclient.OnchainTransaction, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListOnchainTransactions")
	}

	var r0 []lnclient.OnchainTransaction
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]lnclient.OnchainTransaction, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []lnclient.OnchainTransaction); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]lnclient.OnchainTransaction)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_ListOnchainTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListOnchainTransactions'
type MockLNClient_ListOnchainTransactions_Call struct {
	*mock.Call
}

// ListOnchainTransactions is a helper method to define mock.On call
//   - ctx
func (_e *MockLNClient_Expecter) ListOnchainTransactions(ctx interface{}) *MockLNClient_ListOnchainTransactions_Call {
	return &MockLNClient_ListOnchainTransactions_Call{Call: _e.mock.On("ListOnchainTransactions", ctx)}
}

func (_c *MockLNClient_ListOnchainTransactions_Call) Run(run func(ctx context.Context)) *MockLNClient_ListOnchainTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLNClient_ListOnchainTransactions_Call) Return(onchainTransactions []lnclient.OnchainTransaction, err error) *MockLNClient_ListOnchainTransactions_Call {
	_c.Call.Return(onchainTransactions, err)
	return _c
}

func (_c *MockLNClient_ListOnchainTransactions_Call) RunAndReturn(run func(ctx context.Context) ([]lnclient.OnchainTransaction, error)) *MockLNClient_ListOnchainTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// ListPeers provides a mock function for the type MockLNClient
func (_mock *MockLNClient) ListPeers(ctx context.Context) ([]lnclient.PeerDetails, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListPeers")
	}

	var r0 []lnclient.PeerDetails
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]lnclient.PeerDetails, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []lnclient.PeerDetails); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]lnclient.PeerDetails)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_ListPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPeers'
type MockLNClient_ListPeers_Call struct {
	*mock.Call
}

// ListPeers is a helper method to define mock.On call
//   - ctx
func (_e *MockLNClient_Expecter) ListPeers(ctx interface{}) *MockLNClient_ListPeers_Call {
	return &MockLNClient_ListPeers_Call{Call: _e.mock.On("ListPeers", ctx)}
}

func (_c *MockLNClient_ListPeers_Call) Run(run func(ctx context.Context)) *MockLNClient_ListPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLNClient_ListPeers_Call) Return(peerDetailss []lnclient.PeerDetails, err error) *MockLNClient_ListPeers_Call {
	_c.Call.Return(peerDetailss, err)
	return _c
}

func (_c *MockLNClient_ListPeers_Call) RunAndReturn(run func(ctx context.Context) ([]lnclient.PeerDetails, error)) *MockLNClient_ListPeers_Call {
	_c.Call.Return(run)
	return _c
}

// ListTransactions provides a mock function for the type MockLNClient
func (_mock *MockLNClient) ListTransactions(ctx context.Context, from uint64, until uint64, limit uint64, offset uint64, unpaid bool, invoiceType string) ([]lnclient.Transaction, error) {
	ret := _mock.Called(ctx, from, until, limit, offset, unpaid, invoiceType)

	if len(ret) == 0 {
		panic("no return value specified for ListTransactions")
	}

	var r0 []lnclient.Transaction
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, uint64, uint64, uint64, bool, string) ([]lnclient.Transaction, error)); ok {
		return returnFunc(ctx, from, until, limit, offset, unpaid, invoiceType)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, uint64, uint64, uint64, bool, string) []lnclient.Transaction); ok {
		r0 = returnFunc(ctx, from, until, limit, offset, unpaid, invoiceType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]lnclient.Transaction)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint64, uint64, uint64, uint64, bool, string) error); ok {
		r1 = returnFunc(ctx, from, until, limit, offset, unpaid, invoiceType)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_ListTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTransactions'
type MockLNClient_ListTransactions_Call struct {
	*mock.Call
}

// ListTransactions is a helper method to define mock.On call
//   - ctx
//   - from
//   - until
//   - limit
//   - offset
//   - unpaid
//   - invoiceType
func (_e *MockLNClient_Expecter) ListTransactions(ctx interface{}, from interface{}, until interface{}, limit interface{}, offset interface{}, unpaid interface{}, invoiceType interface{}) *MockLNClient_ListTransactions_Call {
	return &MockLNClient_ListTransactions_Call{Call: _e.mock.On("ListTransactions", ctx, from, until, limit, offset, unpaid, invoiceType)}
}

func (_c *MockLNClient_ListTransactions_Call) Run(run func(ctx context.Context, from uint64, until uint64, limit uint64, offset uint64, unpaid bool, invoiceType string)) *MockLNClient_ListTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(uint64), args[3].(uint64), args[4].(uint64), args[5].(bool), args[6].(string))
	})
	return _c
}

func (_c *MockLNClient_ListTransactions_Call) Return(transactions []lnclient.Transaction, err error) *MockLNClient_ListTransactions_Call {
	_c.Call.Return(transactions, err)
	return _c
}

func (_c *MockLNClient_ListTransactions_Call) RunAndReturn(run func(ctx context.Context, from uint64, until uint64, limit uint64, offset uint64, unpaid bool, invoiceType string) ([]lnclient.Transaction, error)) *MockLNClient_ListTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// LookupInvoice provides a mock function for the type MockLNClient
func (_mock *MockLNClient) LookupInvoice(ctx context.Context, paymentHash string) (*lnclient.Transaction, error) {
	ret := _mock.Called(ctx, paymentHash)

	if len(ret) == 0 {
		panic("no return value specified for LookupInvoice")
	}

	var r0 *lnclient.Transaction
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*lnclient.Transaction, error)); ok {
		return returnFunc(ctx, paymentHash)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *lnclient.Transaction); ok {
		r0 = returnFunc(ctx, paymentHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.Transaction)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, paymentHash)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_LookupInvoice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LookupInvoice'
type MockLNClient_LookupInvoice_Call struct {
	*mock.Call
}

// LookupInvoice is a helper method to define mock.On call
//   - ctx
//   - paymentHash
func (_e *MockLNClient_Expecter) LookupInvoice(ctx interface{}, paymentHash interface{}) *MockLNClient_LookupInvoice_Call {
	return &MockLNClient_LookupInvoice_Call{Call: _e.mock.On("LookupInvoice", ctx, paymentHash)}
}

func (_c *MockLNClient_LookupInvoice_Call) Run(run func(ctx context.Context, paymentHash string)) *MockLNClient_LookupInvoice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLNClient_LookupInvoice_Call) Return(transaction *lnclient.Transaction, err error) *MockLNClient_LookupInvoice_Call {
	_c.Call.Return(transaction, err)
	return _c
}

func (_c *MockLNClient_LookupInvoice_Call) RunAndReturn(run func(ctx context.Context, paymentHash string) (*lnclient.Transaction, error)) *MockLNClient_LookupInvoice_Call {
	_c.Call.Return(run)
	return _c
}

// MakeHoldInvoice provides a mock function for the type MockLNClient
func (_mock *MockLNClient) MakeHoldInvoice(ctx context.Context, amount int64, description string, descriptionHash string, expiry int64, paymentHash string) (*lnclient.Transaction, error) {
	ret := _mock.Called(ctx, amount, description, descriptionHash, expiry, paymentHash)

	if len(ret) == 0 {
		panic("no return value specified for MakeHoldInvoice")
	}

	var r0 *lnclient.Transaction
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, int64, string) (*lnclient.Transaction, error)); ok {
		return returnFunc(ctx, amount, description, descriptionHash, expiry, paymentHash)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, int64, string) *lnclient.Transaction); ok {
		r0 = returnFunc(ctx, amount, description, descriptionHash, expiry, paymentHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.Transaction)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string, string, int64, string) error); ok {
		r1 = returnFunc(ctx, amount, description, descriptionHash, expiry, paymentHash)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_MakeHoldInvoice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MakeHoldInvoice'
type MockLNClient_MakeHoldInvoice_Call struct {
	*mock.Call
}

// MakeHoldInvoice is a helper method to define mock.On call
//   - ctx
//   - amount
//   - description
//   - descriptionHash
//   - expiry
//   - paymentHash
func (_e *MockLNClient_Expecter) MakeHoldInvoice(ctx interface{}, amount interface{}, description interface{}, descriptionHash interface{}, expiry interface{}, paymentHash interface{}) *MockLNClient_MakeHoldInvoice_Call {
	return &MockLNClient_MakeHoldInvoice_Call{Call: _e.mock.On("MakeHoldInvoice", ctx, amount, description, descriptionHash, expiry, paymentHash)}
}

func (_c *MockLNClient_MakeHoldInvoice_Call) Run(run func(ctx context.Context, amount int64, description string, descriptionHash string, expiry int64, paymentHash string)) *MockLNClient_MakeHoldInvoice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(string), args[3].(string), args[4].(int64), args[5].(string))
	})
	return _c
}

func (_c *MockLNClient_MakeHoldInvoice_Call) Return(transaction *lnclient.Transaction, err error) *MockLNClient_MakeHoldInvoice_Call {
	_c.Call.Return(transaction, err)
	return _c
}

func (_c *MockLNClient_MakeHoldInvoice_Call) RunAndReturn(run func(ctx context.Context, amount int64, description string, descriptionHash string, expiry int64, paymentHash string) (*lnclient.Transaction, error)) *MockLNClient_MakeHoldInvoice_Call {
	_c.Call.Return(run)
	return _c
}

// MakeInvoice provides a mock function for the type MockLNClient
func (_mock *MockLNClient) MakeInvoice(ctx context.Context, amount int64, description string, descriptionHash string, expiry int64) (*lnclient.Transaction, error) {
	ret := _mock.Called(ctx, amount, description, descriptionHash, expiry)

	if len(ret) == 0 {
		panic("no return value specified for MakeInvoice")
	}

	var r0 *lnclient.Transaction
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, int64) (*lnclient.Transaction, error)); ok {
		return returnFunc(ctx, amount, description, descriptionHash, expiry)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int64, string, string, int64) *lnclient.Transaction); ok {
		r0 = returnFunc(ctx, amount, description, descriptionHash, expiry)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.Transaction)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int64, string, string, int64) error); ok {
		r1 = returnFunc(ctx, amount, description, descriptionHash, expiry)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_MakeInvoice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MakeInvoice'
type MockLNClient_MakeInvoice_Call struct {
	*mock.Call
}

// MakeInvoice is a helper method to define mock.On call
//   - ctx
//   - amount
//   - description
//   - descriptionHash
//   - expiry
func (_e *MockLNClient_Expecter) MakeInvoice(ctx interface{}, amount interface{}, description interface{}, descriptionHash interface{}, expiry interface{}) *MockLNClient_MakeInvoice_Call {
	return &MockLNClient_MakeInvoice_Call{Call: _e.mock.On("MakeInvoice", ctx, amount, description, descriptionHash, expiry)}
}

func (_c *MockLNClient_MakeInvoice_Call) Run(run func(ctx context.Context, amount int64, description string, descriptionHash string, expiry int64)) *MockLNClient_MakeInvoice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(string), args[3].(string), args[4].(int64))
	})
	return _c
}

func (_c *MockLNClient_MakeInvoice_Call) Return(transaction *lnclient.Transaction, err error) *MockLNClient_MakeInvoice_Call {
	_c.Call.Return(transaction, err)
	return _c
}

func (_c *MockLNClient_MakeInvoice_Call) RunAndReturn(run func(ctx context.Context, amount int64, description string, descriptionHash string, expiry int64) (*lnclient.Transaction, error)) *MockLNClient_MakeInvoice_Call {
	_c.Call.Return(run)
	return _c
}

// MakeOffer provides a mock function for the type MockLNClient
func (_mock *MockLNClient) MakeOffer(ctx context.Context, description string) (string, error) {
	ret := _mock.Called(ctx, description)

	if len(ret) == 0 {
		panic("no return value specified for MakeOffer")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return returnFunc(ctx, description)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = returnFunc(ctx, description)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, description)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_MakeOffer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MakeOffer'
type MockLNClient_MakeOffer_Call struct {
	*mock.Call
}

// MakeOffer is a helper method to define mock.On call
//   - ctx
//   - description
func (_e *MockLNClient_Expecter) MakeOffer(ctx interface{}, description interface{}) *MockLNClient_MakeOffer_Call {
	return &MockLNClient_MakeOffer_Call{Call: _e.mock.On("MakeOffer", ctx, description)}
}

func (_c *MockLNClient_MakeOffer_Call) Run(run func(ctx context.Context, description string)) *MockLNClient_MakeOffer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLNClient_MakeOffer_Call) Return(s string, err error) *MockLNClient_MakeOffer_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockLNClient_MakeOffer_Call) RunAndReturn(run func(ctx context.Context, description string) (string, error)) *MockLNClient_MakeOffer_Call {
	_c.Call.Return(run)
	return _c
}

// OpenChannel provides a mock function for the type MockLNClient
func (_mock *MockLNClient) OpenChannel(ctx context.Context, openChannelRequest *lnclient.OpenChannelRequest) (*lnclient.OpenChannelResponse, error) {
	ret := _mock.Called(ctx, openChannelRequest)

	if len(ret) == 0 {
		panic("no return value specified for OpenChannel")
	}

	var r0 *lnclient.OpenChannelResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *lnclient.OpenChannelRequest) (*lnclient.OpenChannelResponse, error)); ok {
		return returnFunc(ctx, openChannelRequest)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *lnclient.OpenChannelRequest) *lnclient.OpenChannelResponse); ok {
		r0 = returnFunc(ctx, openChannelRequest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.OpenChannelResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *lnclient.OpenChannelRequest) error); ok {
		r1 = returnFunc(ctx, openChannelRequest)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_OpenChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OpenChannel'
type MockLNClient_OpenChannel_Call struct {
	*mock.Call
}

// OpenChannel is a helper method to define mock.On call
//   - ctx
//   - openChannelRequest
func (_e *MockLNClient_Expecter) OpenChannel(ctx interface{}, openChannelRequest interface{}) *MockLNClient_OpenChannel_Call {
	return &MockLNClient_OpenChannel_Call{Call: _e.mock.On("OpenChannel", ctx, openChannelRequest)}
}

func (_c *MockLNClient_OpenChannel_Call) Run(run func(ctx context.Context, openChannelRequest *lnclient.OpenChannelRequest)) *MockLNClient_OpenChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*lnclient.OpenChannelRequest))
	})
	return _c
}

func (_c *MockLNClient_OpenChannel_Call) Return(openChannelResponse *lnclient.OpenChannelResponse, err error) *MockLNClient_OpenChannel_Call {
	_c.Call.Return(openChannelResponse, err)
	return _c
}

func (_c *MockLNClient_OpenChannel_Call) RunAndReturn(run func(ctx context.Context, openChannelRequest *lnclient.OpenChannelRequest) (*lnclient.OpenChannelResponse, error)) *MockLNClient_OpenChannel_Call {
	_c.Call.Return(run)
	return _c
}

// RedeemOnchainFunds provides a mock function for the type MockLNClient
func (_mock *MockLNClient) RedeemOnchainFunds(ctx context.Context, toAddress string, amount uint64, feeRate *uint64, sendAll bool) (string, error) {
	ret := _mock.Called(ctx, toAddress, amount, feeRate, sendAll)

	if len(ret) == 0 {
		panic("no return value specified for RedeemOnchainFunds")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, uint64, *uint64, bool) (string, error)); ok {
		return returnFunc(ctx, toAddress, amount, feeRate, sendAll)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, uint64, *uint64, bool) string); ok {
		r0 = returnFunc(ctx, toAddress, amount, feeRate, sendAll)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, uint64, *uint64, bool) error); ok {
		r1 = returnFunc(ctx, toAddress, amount, feeRate, sendAll)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_RedeemOnchainFunds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RedeemOnchainFunds'
type MockLNClient_RedeemOnchainFunds_Call struct {
	*mock.Call
}

// RedeemOnchainFunds is a helper method to define mock.On call
//   - ctx
//   - toAddress
//   - amount
//   - feeRate
//   - sendAll
func (_e *MockLNClient_Expecter) RedeemOnchainFunds(ctx interface{}, toAddress interface{}, amount interface{}, feeRate interface{}, sendAll interface{}) *MockLNClient_RedeemOnchainFunds_Call {
	return &MockLNClient_RedeemOnchainFunds_Call{Call: _e.mock.On("RedeemOnchainFunds", ctx, toAddress, amount, feeRate, sendAll)}
}

func (_c *MockLNClient_RedeemOnchainFunds_Call) Run(run func(ctx context.Context, toAddress string, amount uint64, feeRate *uint64, sendAll bool)) *MockLNClient_RedeemOnchainFunds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64), args[3].(*uint64), args[4].(bool))
	})
	return _c
}

func (_c *MockLNClient_RedeemOnchainFunds_Call) Return(txId string, err error) *MockLNClient_RedeemOnchainFunds_Call {
	_c.Call.Return(txId, err)
	return _c
}

func (_c *MockLNClient_RedeemOnchainFunds_Call) RunAndReturn(run func(ctx context.Context, toAddress string, amount uint64, feeRate *uint64, sendAll bool) (string, error)) *MockLNClient_RedeemOnchainFunds_Call {
	_c.Call.Return(run)
	return _c
}

// ResetRouter provides a mock function for the type MockLNClient
func (_mock *MockLNClient) ResetRouter(key string) error {
	ret := _mock.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for ResetRouter")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(string) error); ok {
		r0 = returnFunc(key)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockLNClient_ResetRouter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetRouter'
type MockLNClient_ResetRouter_Call struct {
	*mock.Call
}

// ResetRouter is a helper method to define mock.On call
//   - key
func (_e *MockLNClient_Expecter) ResetRouter(key interface{}) *MockLNClient_ResetRouter_Call {
	return &MockLNClient_ResetRouter_Call{Call: _e.mock.On("ResetRouter", key)}
}

func (_c *MockLNClient_ResetRouter_Call) Run(run func(key string)) *MockLNClient_ResetRouter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockLNClient_ResetRouter_Call) Return(err error) *MockLNClient_ResetRouter_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockLNClient_ResetRouter_Call) RunAndReturn(run func(key string) error) *MockLNClient_ResetRouter_Call {
	_c.Call.Return(run)
	return _c
}

// SendKeysend provides a mock function for the type MockLNClient
func (_mock *MockLNClient) SendKeysend(ctx context.Context, amount uint64, destination string, customRecords []lnclient.TLVRecord, preimage string) (*lnclient.PayKeysendResponse, error) {
	ret := _mock.Called(ctx, amount, destination, customRecords, preimage)

	if len(ret) == 0 {
		panic("no return value specified for SendKeysend")
	}

	var r0 *lnclient.PayKeysendResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, string, []lnclient.TLVRecord, string) (*lnclient.PayKeysendResponse, error)); ok {
		return returnFunc(ctx, amount, destination, customRecords, preimage)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, string, []lnclient.TLVRecord, string) *lnclient.PayKeysendResponse); ok {
		r0 = returnFunc(ctx, amount, destination, customRecords, preimage)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.PayKeysendResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint64, string, []lnclient.TLVRecord, string) error); ok {
		r1 = returnFunc(ctx, amount, destination, customRecords, preimage)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_SendKeysend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendKeysend'
type MockLNClient_SendKeysend_Call struct {
	*mock.Call
}

// SendKeysend is a helper method to define mock.On call
//   - ctx
//   - amount
//   - destination
//   - customRecords
//   - preimage
func (_e *MockLNClient_Expecter) SendKeysend(ctx interface{}, amount interface{}, destination interface{}, customRecords interface{}, preimage interface{}) *MockLNClient_SendKeysend_Call {
	return &MockLNClient_SendKeysend_Call{Call: _e.mock.On("SendKeysend", ctx, amount, destination, customRecords, preimage)}
}

func (_c *MockLNClient_SendKeysend_Call) Run(run func(ctx context.Context, amount uint64, destination string, customRecords []lnclient.TLVRecord, preimage string)) *MockLNClient_SendKeysend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(string), args[3].([]lnclient.TLVRecord), args[4].(string))
	})
	return _c
}

func (_c *MockLNClient_SendKeysend_Call) Return(payKeysendResponse *lnclient.PayKeysendResponse, err error) *MockLNClient_SendKeysend_Call {
	_c.Call.Return(payKeysendResponse, err)
	return _c
}

func (_c *MockLNClient_SendKeysend_Call) RunAndReturn(run func(ctx context.Context, amount uint64, destination string, customRecords []lnclient.TLVRecord, preimage string) (*lnclient.PayKeysendResponse, error)) *MockLNClient_SendKeysend_Call {
	_c.Call.Return(run)
	return _c
}

// SendPaymentProbes provides a mock function for the type MockLNClient
func (_mock *MockLNClient) SendPaymentProbes(ctx context.Context, invoice string) error {
	ret := _mock.Called(ctx, invoice)

	if len(ret) == 0 {
		panic("no return value specified for SendPaymentProbes")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, invoice)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockLNClient_SendPaymentProbes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendPaymentProbes'
type MockLNClient_SendPaymentProbes_Call struct {
	*mock.Call
}

// SendPaymentProbes is a helper method to define mock.On call
//   - ctx
//   - invoice
func (_e *MockLNClient_Expecter) SendPaymentProbes(ctx interface{}, invoice interface{}) *MockLNClient_SendPaymentProbes_Call {
	return &MockLNClient_SendPaymentProbes_Call{Call: _e.mock.On("SendPaymentProbes", ctx, invoice)}
}

func (_c *MockLNClient_SendPaymentProbes_Call) Run(run func(ctx context.Context, invoice string)) *MockLNClient_SendPaymentProbes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLNClient_SendPaymentProbes_Call) Return(err error) *MockLNClient_SendPaymentProbes_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockLNClient_SendPaymentProbes_Call) RunAndReturn(run func(ctx context.Context, invoice string) error) *MockLNClient_SendPaymentProbes_Call {
	_c.Call.Return(run)
	return _c
}

// SendPaymentSync provides a mock function for the type MockLNClient
func (_mock *MockLNClient) SendPaymentSync(ctx context.Context, payReq string, amount *uint64) (*lnclient.PayInvoiceResponse, error) {
	ret := _mock.Called(ctx, payReq, amount)

	if len(ret) == 0 {
		panic("no return value specified for SendPaymentSync")
	}

	var r0 *lnclient.PayInvoiceResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *uint64) (*lnclient.PayInvoiceResponse, error)); ok {
		return returnFunc(ctx, payReq, amount)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, *uint64) *lnclient.PayInvoiceResponse); ok {
		r0 = returnFunc(ctx, payReq, amount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.PayInvoiceResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, *uint64) error); ok {
		r1 = returnFunc(ctx, payReq, amount)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_SendPaymentSync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendPaymentSync'
type MockLNClient_SendPaymentSync_Call struct {
	*mock.Call
}

// SendPaymentSync is a helper method to define mock.On call
//   - ctx
//   - payReq
//   - amount
func (_e *MockLNClient_Expecter) SendPaymentSync(ctx interface{}, payReq interface{}, amount interface{}) *MockLNClient_SendPaymentSync_Call {
	return &MockLNClient_SendPaymentSync_Call{Call: _e.mock.On("SendPaymentSync", ctx, payReq, amount)}
}

func (_c *MockLNClient_SendPaymentSync_Call) Run(run func(ctx context.Context, payReq string, amount *uint64)) *MockLNClient_SendPaymentSync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*uint64))
	})
	return _c
}

func (_c *MockLNClient_SendPaymentSync_Call) Return(payInvoiceResponse *lnclient.PayInvoiceResponse, err error) *MockLNClient_SendPaymentSync_Call {
	_c.Call.Return(payInvoiceResponse, err)
	return _c
}

func (_c *MockLNClient_SendPaymentSync_Call) RunAndReturn(run func(ctx context.Context, payReq string, amount *uint64) (*lnclient.PayInvoiceResponse, error)) *MockLNClient_SendPaymentSync_Call {
	_c.Call.Return(run)
	return _c
}

// SendSpontaneousPaymentProbes provides a mock function for the type MockLNClient
func (_mock *MockLNClient) SendSpontaneousPaymentProbes(ctx context.Context, amountMsat uint64, nodeId string) error {
	ret := _mock.Called(ctx, amountMsat, nodeId)

	if len(ret) == 0 {
		panic("no return value specified for SendSpontaneousPaymentProbes")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, string) error); ok {
		r0 = returnFunc(ctx, amountMsat, nodeId)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockLNClient_SendSpontaneousPaymentProbes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendSpontaneousPaymentProbes'
type MockLNClient_SendSpontaneousPaymentProbes_Call struct {
	*mock.Call
}

// SendSpontaneousPaymentProbes is a helper method to define mock.On call
//   - ctx
//   - amountMsat
//   - nodeId
func (_e *MockLNClient_Expecter) SendSpontaneousPaymentProbes(ctx interface{}, amountMsat interface{}, nodeId interface{}) *MockLNClient_SendSpontaneousPaymentProbes_Call {
	return &MockLNClient_SendSpontaneousPaymentProbes_Call{Call: _e.mock.On("SendSpontaneousPaymentProbes", ctx, amountMsat, nodeId)}
}

func (_c *MockLNClient_SendSpontaneousPaymentProbes_Call) Run(run func(ctx context.Context, amountMsat uint64, nodeId string)) *MockLNClient_SendSpontaneousPaymentProbes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(string))
	})
	return _c
}

func (_c *MockLNClient_SendSpontaneousPaymentProbes_Call) Return(err error) *MockLNClient_SendSpontaneousPaymentProbes_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockLNClient_SendSpontaneousPaymentProbes_Call) RunAndReturn(run func(ctx context.Context, amountMsat uint64, nodeId string) error) *MockLNClient_SendSpontaneousPaymentProbes_Call {
	_c.Call.Return(run)
	return _c
}

// SettleHoldInvoice provides a mock function for the type MockLNClient
func (_mock *MockLNClient) SettleHoldInvoice(ctx context.Context, preimage string) error {
	ret := _mock.Called(ctx, preimage)

	if len(ret) == 0 {
		panic("no return value specified for SettleHoldInvoice")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, preimage)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockLNClient_SettleHoldInvoice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SettleHoldInvoice'
type MockLNClient_SettleHoldInvoice_Call struct {
	*mock.Call
}

// SettleHoldInvoice is a helper method to define mock.On call
//   - ctx
//   - preimage
func (_e *MockLNClient_Expecter) SettleHoldInvoice(ctx interface{}, preimage interface{}) *MockLNClient_SettleHoldInvoice_Call {
	return &MockLNClient_SettleHoldInvoice_Call{Call: _e.mock.On("SettleHoldInvoice", ctx, preimage)}
}

func (_c *MockLNClient_SettleHoldInvoice_Call) Run(run func(ctx context.Context, preimage string)) *MockLNClient_SettleHoldInvoice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLNClient_SettleHoldInvoice_Call) Return(err error) *MockLNClient_SettleHoldInvoice_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockLNClient_SettleHoldInvoice_Call) RunAndReturn(run func(ctx context.Context, preimage string) error) *MockLNClient_SettleHoldInvoice_Call {
	_c.Call.Return(run)
	return _c
}

// Shutdown provides a mock function for the type MockLNClient
func (_mock *MockLNClient) Shutdown() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Shutdown")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockLNClient_Shutdown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Shutdown'
type MockLNClient_Shutdown_Call struct {
	*mock.Call
}

// Shutdown is a helper method to define mock.On call
func (_e *MockLNClient_Expecter) Shutdown() *MockLNClient_Shutdown_Call {
	return &MockLNClient_Shutdown_Call{Call: _e.mock.On("Shutdown")}
}

func (_c *MockLNClient_Shutdown_Call) Run(run func()) *MockLNClient_Shutdown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLNClient_Shutdown_Call) Return(err error) *MockLNClient_Shutdown_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockLNClient_Shutdown_Call) RunAndReturn(run func() error) *MockLNClient_Shutdown_Call {
	_c.Call.Return(run)
	return _c
}

// SignMessage provides a mock function for the type MockLNClient
func (_mock *MockLNClient) SignMessage(ctx context.Context, message string) (string, error) {
	ret := _mock.Called(ctx, message)

	if len(ret) == 0 {
		panic("no return value specified for SignMessage")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return returnFunc(ctx, message)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = returnFunc(ctx, message)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, message)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLNClient_SignMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignMessage'
type MockLNClient_SignMessage_Call struct {
	*mock.Call
}

// SignMessage is a helper method to define mock.On call
//   - ctx
//   - message
func (_e *MockLNClient_Expecter) SignMessage(ctx interface{}, message interface{}) *MockLNClient_SignMessage_Call {
	return &MockLNClient_SignMessage_Call{Call: _e.mock.On("SignMessage", ctx, message)}
}

func (_c *MockLNClient_SignMessage_Call) Run(run func(ctx context.Context, message string)) *MockLNClient_SignMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLNClient_SignMessage_Call) Return(s string, err error) *MockLNClient_SignMessage_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockLNClient_SignMessage_Call) RunAndReturn(run func(ctx context.Context, message string) (string, error)) *MockLNClient_SignMessage_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateChannel provides a mock function for the type MockLNClient
func (_mock *MockLNClient) UpdateChannel(ctx context.Context, updateChannelRequest *lnclient.UpdateChannelRequest) error {
	ret := _mock.Called(ctx, updateChannelRequest)

	if len(ret) == 0 {
		panic("no return value specified for UpdateChannel")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *lnclient.UpdateChannelRequest) error); ok {
		r0 = returnFunc(ctx, updateChannelRequest)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockLNClient_UpdateChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateChannel'
type MockLNClient_UpdateChannel_Call struct {
	*mock.Call
}

// UpdateChannel is a helper method to define mock.On call
//   - ctx
//   - updateChannelRequest
func (_e *MockLNClient_Expecter) UpdateChannel(ctx interface{}, updateChannelRequest interface{}) *MockLNClient_UpdateChannel_Call {
	return &MockLNClient_UpdateChannel_Call{Call: _e.mock.On("UpdateChannel", ctx, updateChannelRequest)}
}

func (_c *MockLNClient_UpdateChannel_Call) Run(run func(ctx context.Context, updateChannelRequest *lnclient.UpdateChannelRequest)) *MockLNClient_UpdateChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*lnclient.UpdateChannelRequest))
	})
	return _c
}

func (_c *MockLNClient_UpdateChannel_Call) Return(err error) *MockLNClient_UpdateChannel_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockLNClient_UpdateChannel_Call) RunAndReturn(run func(ctx context.Context, updateChannelRequest *lnclient.UpdateChannelRequest) error) *MockLNClient_UpdateChannel_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateLastWalletSyncRequest provides a mock function for the type MockLNClient
func (_mock *MockLNClient) UpdateLastWalletSyncRequest() {
	_mock.Called()
	return
}

// MockLNClient_UpdateLastWalletSyncRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateLastWalletSyncRequest'
type MockLNClient_UpdateLastWalletSyncRequest_Call struct {
	*mock.Call
}

// UpdateLastWalletSyncRequest is a helper method to define mock.On call
func (_e *MockLNClient_Expecter) UpdateLastWalletSyncRequest() *MockLNClient_UpdateLastWalletSyncRequest_Call {
	return &MockLNClient_UpdateLastWalletSyncRequest_Call{Call: _e.mock.On("UpdateLastWalletSyncRequest")}
}

func (_c *MockLNClient_UpdateLastWalletSyncRequest_Call) Run(run func()) *MockLNClient_UpdateLastWalletSyncRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLNClient_UpdateLastWalletSyncRequest_Call) Return() *MockLNClient_UpdateLastWalletSyncRequest_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLNClient_UpdateLastWalletSyncRequest_Call) RunAndReturn(run func()) *MockLNClient_UpdateLastWalletSyncRequest_Call {
	_c.Run(run)
	return _c
}
