// Code generated by mockery v2.53.2. DO NOT EDIT.

package mocks

import (
	context "context"

	lnclient "github.com/getAlby/hub/lnclient"
	mock "github.com/stretchr/testify/mock"
)

// MockLNClient is an autogenerated mock type for the LNClient type
type MockLNClient struct {
	mock.Mock
}

type MockLNClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLNClient) EXPECT() *MockLNClient_Expecter {
	return &MockLNClient_Expecter{mock: &_m.Mock}
}

// CloseChannel provides a mock function with given fields: ctx, closeChannelRequest
func (_m *MockLNClient) CloseChannel(ctx context.Context, closeChannelRequest *lnclient.CloseChannelRequest) (*lnclient.CloseChannelResponse, error) {
	ret := _m.Called(ctx, closeChannelRequest)

	if len(ret) == 0 {
		panic("no return value specified for CloseChannel")
	}

	var r0 *lnclient.CloseChannelResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnclient.CloseChannelRequest) (*lnclient.CloseChannelResponse, error)); ok {
		return rf(ctx, closeChannelRequest)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnclient.CloseChannelRequest) *lnclient.CloseChannelResponse); ok {
		r0 = rf(ctx, closeChannelRequest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.CloseChannelResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnclient.CloseChannelRequest) error); ok {
		r1 = rf(ctx, closeChannelRequest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_CloseChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CloseChannel'
type MockLNClient_CloseChannel_Call struct {
	*mock.Call
}

// CloseChannel is a helper method to define mock.On call
//   - ctx context.Context
//   - closeChannelRequest *lnclient.CloseChannelRequest
func (_e *MockLNClient_Expecter) CloseChannel(ctx interface{}, closeChannelRequest interface{}) *MockLNClient_CloseChannel_Call {
	return &MockLNClient_CloseChannel_Call{Call: _e.mock.On("CloseChannel", ctx, closeChannelRequest)}
}

func (_c *MockLNClient_CloseChannel_Call) Run(run func(ctx context.Context, closeChannelRequest *lnclient.CloseChannelRequest)) *MockLNClient_CloseChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*lnclient.CloseChannelRequest))
	})
	return _c
}

func (_c *MockLNClient_CloseChannel_Call) Return(_a0 *lnclient.CloseChannelResponse, _a1 error) *MockLNClient_CloseChannel_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLNClient_CloseChannel_Call) RunAndReturn(run func(context.Context, *lnclient.CloseChannelRequest) (*lnclient.CloseChannelResponse, error)) *MockLNClient_CloseChannel_Call {
	_c.Call.Return(run)
	return _c
}

// ConnectPeer provides a mock function with given fields: ctx, connectPeerRequest
func (_m *MockLNClient) ConnectPeer(ctx context.Context, connectPeerRequest *lnclient.ConnectPeerRequest) error {
	ret := _m.Called(ctx, connectPeerRequest)

	if len(ret) == 0 {
		panic("no return value specified for ConnectPeer")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnclient.ConnectPeerRequest) error); ok {
		r0 = rf(ctx, connectPeerRequest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLNClient_ConnectPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConnectPeer'
type MockLNClient_ConnectPeer_Call struct {
	*mock.Call
}

// ConnectPeer is a helper method to define mock.On call
//   - ctx context.Context
//   - connectPeerRequest *lnclient.ConnectPeerRequest
func (_e *MockLNClient_Expecter) ConnectPeer(ctx interface{}, connectPeerRequest interface{}) *MockLNClient_ConnectPeer_Call {
	return &MockLNClient_ConnectPeer_Call{Call: _e.mock.On("ConnectPeer", ctx, connectPeerRequest)}
}

func (_c *MockLNClient_ConnectPeer_Call) Run(run func(ctx context.Context, connectPeerRequest *lnclient.ConnectPeerRequest)) *MockLNClient_ConnectPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*lnclient.ConnectPeerRequest))
	})
	return _c
}

func (_c *MockLNClient_ConnectPeer_Call) Return(_a0 error) *MockLNClient_ConnectPeer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLNClient_ConnectPeer_Call) RunAndReturn(run func(context.Context, *lnclient.ConnectPeerRequest) error) *MockLNClient_ConnectPeer_Call {
	_c.Call.Return(run)
	return _c
}

// DisconnectPeer provides a mock function with given fields: ctx, peerId
func (_m *MockLNClient) DisconnectPeer(ctx context.Context, peerId string) error {
	ret := _m.Called(ctx, peerId)

	if len(ret) == 0 {
		panic("no return value specified for DisconnectPeer")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, peerId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLNClient_DisconnectPeer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisconnectPeer'
type MockLNClient_DisconnectPeer_Call struct {
	*mock.Call
}

// DisconnectPeer is a helper method to define mock.On call
//   - ctx context.Context
//   - peerId string
func (_e *MockLNClient_Expecter) DisconnectPeer(ctx interface{}, peerId interface{}) *MockLNClient_DisconnectPeer_Call {
	return &MockLNClient_DisconnectPeer_Call{Call: _e.mock.On("DisconnectPeer", ctx, peerId)}
}

func (_c *MockLNClient_DisconnectPeer_Call) Run(run func(ctx context.Context, peerId string)) *MockLNClient_DisconnectPeer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLNClient_DisconnectPeer_Call) Return(_a0 error) *MockLNClient_DisconnectPeer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLNClient_DisconnectPeer_Call) RunAndReturn(run func(context.Context, string) error) *MockLNClient_DisconnectPeer_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteCustomNodeCommand provides a mock function with given fields: ctx, command
func (_m *MockLNClient) ExecuteCustomNodeCommand(ctx context.Context, command *lnclient.CustomNodeCommandRequest) (*lnclient.CustomNodeCommandResponse, error) {
	ret := _m.Called(ctx, command)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteCustomNodeCommand")
	}

	var r0 *lnclient.CustomNodeCommandResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnclient.CustomNodeCommandRequest) (*lnclient.CustomNodeCommandResponse, error)); ok {
		return rf(ctx, command)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnclient.CustomNodeCommandRequest) *lnclient.CustomNodeCommandResponse); ok {
		r0 = rf(ctx, command)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.CustomNodeCommandResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnclient.CustomNodeCommandRequest) error); ok {
		r1 = rf(ctx, command)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_ExecuteCustomNodeCommand_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteCustomNodeCommand'
type MockLNClient_ExecuteCustomNodeCommand_Call struct {
	*mock.Call
}

// ExecuteCustomNodeCommand is a helper method to define mock.On call
//   - ctx context.Context
//   - command *lnclient.CustomNodeCommandRequest
func (_e *MockLNClient_Expecter) ExecuteCustomNodeCommand(ctx interface{}, command interface{}) *MockLNClient_ExecuteCustomNodeCommand_Call {
	return &MockLNClient_ExecuteCustomNodeCommand_Call{Call: _e.mock.On("ExecuteCustomNodeCommand", ctx, command)}
}

func (_c *MockLNClient_ExecuteCustomNodeCommand_Call) Run(run func(ctx context.Context, command *lnclient.CustomNodeCommandRequest)) *MockLNClient_ExecuteCustomNodeCommand_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*lnclient.CustomNodeCommandRequest))
	})
	return _c
}

func (_c *MockLNClient_ExecuteCustomNodeCommand_Call) Return(_a0 *lnclient.CustomNodeCommandResponse, _a1 error) *MockLNClient_ExecuteCustomNodeCommand_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLNClient_ExecuteCustomNodeCommand_Call) RunAndReturn(run func(context.Context, *lnclient.CustomNodeCommandRequest) (*lnclient.CustomNodeCommandResponse, error)) *MockLNClient_ExecuteCustomNodeCommand_Call {
	_c.Call.Return(run)
	return _c
}

// GetBalances provides a mock function with given fields: ctx, includeInactiveChannels
func (_m *MockLNClient) GetBalances(ctx context.Context, includeInactiveChannels bool) (*lnclient.BalancesResponse, error) {
	ret := _m.Called(ctx, includeInactiveChannels)

	if len(ret) == 0 {
		panic("no return value specified for GetBalances")
	}

	var r0 *lnclient.BalancesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, bool) (*lnclient.BalancesResponse, error)); ok {
		return rf(ctx, includeInactiveChannels)
	}
	if rf, ok := ret.Get(0).(func(context.Context, bool) *lnclient.BalancesResponse); ok {
		r0 = rf(ctx, includeInactiveChannels)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.BalancesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, bool) error); ok {
		r1 = rf(ctx, includeInactiveChannels)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_GetBalances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBalances'
type MockLNClient_GetBalances_Call struct {
	*mock.Call
}

// GetBalances is a helper method to define mock.On call
//   - ctx context.Context
//   - includeInactiveChannels bool
func (_e *MockLNClient_Expecter) GetBalances(ctx interface{}, includeInactiveChannels interface{}) *MockLNClient_GetBalances_Call {
	return &MockLNClient_GetBalances_Call{Call: _e.mock.On("GetBalances", ctx, includeInactiveChannels)}
}

func (_c *MockLNClient_GetBalances_Call) Run(run func(ctx context.Context, includeInactiveChannels bool)) *MockLNClient_GetBalances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(bool))
	})
	return _c
}

func (_c *MockLNClient_GetBalances_Call) Return(_a0 *lnclient.BalancesResponse, _a1 error) *MockLNClient_GetBalances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLNClient_GetBalances_Call) RunAndReturn(run func(context.Context, bool) (*lnclient.BalancesResponse, error)) *MockLNClient_GetBalances_Call {
	_c.Call.Return(run)
	return _c
}

// GetCustomNodeCommandDefinitions provides a mock function with no fields
func (_m *MockLNClient) GetCustomNodeCommandDefinitions() []lnclient.CustomNodeCommandDef {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetCustomNodeCommandDefinitions")
	}

	var r0 []lnclient.CustomNodeCommandDef
	if rf, ok := ret.Get(0).(func() []lnclient.CustomNodeCommandDef); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]lnclient.CustomNodeCommandDef)
		}
	}

	return r0
}

// MockLNClient_GetCustomNodeCommandDefinitions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCustomNodeCommandDefinitions'
type MockLNClient_GetCustomNodeCommandDefinitions_Call struct {
	*mock.Call
}

// GetCustomNodeCommandDefinitions is a helper method to define mock.On call
func (_e *MockLNClient_Expecter) GetCustomNodeCommandDefinitions() *MockLNClient_GetCustomNodeCommandDefinitions_Call {
	return &MockLNClient_GetCustomNodeCommandDefinitions_Call{Call: _e.mock.On("GetCustomNodeCommandDefinitions")}
}

func (_c *MockLNClient_GetCustomNodeCommandDefinitions_Call) Run(run func()) *MockLNClient_GetCustomNodeCommandDefinitions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLNClient_GetCustomNodeCommandDefinitions_Call) Return(_a0 []lnclient.CustomNodeCommandDef) *MockLNClient_GetCustomNodeCommandDefinitions_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLNClient_GetCustomNodeCommandDefinitions_Call) RunAndReturn(run func() []lnclient.CustomNodeCommandDef) *MockLNClient_GetCustomNodeCommandDefinitions_Call {
	_c.Call.Return(run)
	return _c
}

// GetInfo provides a mock function with given fields: ctx
func (_m *MockLNClient) GetInfo(ctx context.Context) (*lnclient.NodeInfo, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetInfo")
	}

	var r0 *lnclient.NodeInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*lnclient.NodeInfo, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *lnclient.NodeInfo); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.NodeInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_GetInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInfo'
type MockLNClient_GetInfo_Call struct {
	*mock.Call
}

// GetInfo is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockLNClient_Expecter) GetInfo(ctx interface{}) *MockLNClient_GetInfo_Call {
	return &MockLNClient_GetInfo_Call{Call: _e.mock.On("GetInfo", ctx)}
}

func (_c *MockLNClient_GetInfo_Call) Run(run func(ctx context.Context)) *MockLNClient_GetInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLNClient_GetInfo_Call) Return(info *lnclient.NodeInfo, err error) *MockLNClient_GetInfo_Call {
	_c.Call.Return(info, err)
	return _c
}

func (_c *MockLNClient_GetInfo_Call) RunAndReturn(run func(context.Context) (*lnclient.NodeInfo, error)) *MockLNClient_GetInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogOutput provides a mock function with given fields: ctx, maxLen
func (_m *MockLNClient) GetLogOutput(ctx context.Context, maxLen int) ([]byte, error) {
	ret := _m.Called(ctx, maxLen)

	if len(ret) == 0 {
		panic("no return value specified for GetLogOutput")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]byte, error)); ok {
		return rf(ctx, maxLen)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []byte); ok {
		r0 = rf(ctx, maxLen)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, maxLen)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_GetLogOutput_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogOutput'
type MockLNClient_GetLogOutput_Call struct {
	*mock.Call
}

// GetLogOutput is a helper method to define mock.On call
//   - ctx context.Context
//   - maxLen int
func (_e *MockLNClient_Expecter) GetLogOutput(ctx interface{}, maxLen interface{}) *MockLNClient_GetLogOutput_Call {
	return &MockLNClient_GetLogOutput_Call{Call: _e.mock.On("GetLogOutput", ctx, maxLen)}
}

func (_c *MockLNClient_GetLogOutput_Call) Run(run func(ctx context.Context, maxLen int)) *MockLNClient_GetLogOutput_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockLNClient_GetLogOutput_Call) Return(_a0 []byte, _a1 error) *MockLNClient_GetLogOutput_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLNClient_GetLogOutput_Call) RunAndReturn(run func(context.Context, int) ([]byte, error)) *MockLNClient_GetLogOutput_Call {
	_c.Call.Return(run)
	return _c
}

// GetNetworkGraph provides a mock function with given fields: ctx, nodeIds
func (_m *MockLNClient) GetNetworkGraph(ctx context.Context, nodeIds []string) (lnclient.NetworkGraphResponse, error) {
	ret := _m.Called(ctx, nodeIds)

	if len(ret) == 0 {
		panic("no return value specified for GetNetworkGraph")
	}

	var r0 lnclient.NetworkGraphResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) (lnclient.NetworkGraphResponse, error)); ok {
		return rf(ctx, nodeIds)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) lnclient.NetworkGraphResponse); ok {
		r0 = rf(ctx, nodeIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(lnclient.NetworkGraphResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, nodeIds)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_GetNetworkGraph_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNetworkGraph'
type MockLNClient_GetNetworkGraph_Call struct {
	*mock.Call
}

// GetNetworkGraph is a helper method to define mock.On call
//   - ctx context.Context
//   - nodeIds []string
func (_e *MockLNClient_Expecter) GetNetworkGraph(ctx interface{}, nodeIds interface{}) *MockLNClient_GetNetworkGraph_Call {
	return &MockLNClient_GetNetworkGraph_Call{Call: _e.mock.On("GetNetworkGraph", ctx, nodeIds)}
}

func (_c *MockLNClient_GetNetworkGraph_Call) Run(run func(ctx context.Context, nodeIds []string)) *MockLNClient_GetNetworkGraph_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockLNClient_GetNetworkGraph_Call) Return(_a0 lnclient.NetworkGraphResponse, _a1 error) *MockLNClient_GetNetworkGraph_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLNClient_GetNetworkGraph_Call) RunAndReturn(run func(context.Context, []string) (lnclient.NetworkGraphResponse, error)) *MockLNClient_GetNetworkGraph_Call {
	_c.Call.Return(run)
	return _c
}

// GetNewOnchainAddress provides a mock function with given fields: ctx
func (_m *MockLNClient) GetNewOnchainAddress(ctx context.Context) (string, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetNewOnchainAddress")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_GetNewOnchainAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNewOnchainAddress'
type MockLNClient_GetNewOnchainAddress_Call struct {
	*mock.Call
}

// GetNewOnchainAddress is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockLNClient_Expecter) GetNewOnchainAddress(ctx interface{}) *MockLNClient_GetNewOnchainAddress_Call {
	return &MockLNClient_GetNewOnchainAddress_Call{Call: _e.mock.On("GetNewOnchainAddress", ctx)}
}

func (_c *MockLNClient_GetNewOnchainAddress_Call) Run(run func(ctx context.Context)) *MockLNClient_GetNewOnchainAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLNClient_GetNewOnchainAddress_Call) Return(_a0 string, _a1 error) *MockLNClient_GetNewOnchainAddress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLNClient_GetNewOnchainAddress_Call) RunAndReturn(run func(context.Context) (string, error)) *MockLNClient_GetNewOnchainAddress_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodeConnectionInfo provides a mock function with given fields: ctx
func (_m *MockLNClient) GetNodeConnectionInfo(ctx context.Context) (*lnclient.NodeConnectionInfo, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetNodeConnectionInfo")
	}

	var r0 *lnclient.NodeConnectionInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*lnclient.NodeConnectionInfo, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *lnclient.NodeConnectionInfo); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.NodeConnectionInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_GetNodeConnectionInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodeConnectionInfo'
type MockLNClient_GetNodeConnectionInfo_Call struct {
	*mock.Call
}

// GetNodeConnectionInfo is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockLNClient_Expecter) GetNodeConnectionInfo(ctx interface{}) *MockLNClient_GetNodeConnectionInfo_Call {
	return &MockLNClient_GetNodeConnectionInfo_Call{Call: _e.mock.On("GetNodeConnectionInfo", ctx)}
}

func (_c *MockLNClient_GetNodeConnectionInfo_Call) Run(run func(ctx context.Context)) *MockLNClient_GetNodeConnectionInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLNClient_GetNodeConnectionInfo_Call) Return(nodeConnectionInfo *lnclient.NodeConnectionInfo, err error) *MockLNClient_GetNodeConnectionInfo_Call {
	_c.Call.Return(nodeConnectionInfo, err)
	return _c
}

func (_c *MockLNClient_GetNodeConnectionInfo_Call) RunAndReturn(run func(context.Context) (*lnclient.NodeConnectionInfo, error)) *MockLNClient_GetNodeConnectionInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodeStatus provides a mock function with given fields: ctx
func (_m *MockLNClient) GetNodeStatus(ctx context.Context) (*lnclient.NodeStatus, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetNodeStatus")
	}

	var r0 *lnclient.NodeStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*lnclient.NodeStatus, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *lnclient.NodeStatus); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.NodeStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_GetNodeStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodeStatus'
type MockLNClient_GetNodeStatus_Call struct {
	*mock.Call
}

// GetNodeStatus is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockLNClient_Expecter) GetNodeStatus(ctx interface{}) *MockLNClient_GetNodeStatus_Call {
	return &MockLNClient_GetNodeStatus_Call{Call: _e.mock.On("GetNodeStatus", ctx)}
}

func (_c *MockLNClient_GetNodeStatus_Call) Run(run func(ctx context.Context)) *MockLNClient_GetNodeStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLNClient_GetNodeStatus_Call) Return(nodeStatus *lnclient.NodeStatus, err error) *MockLNClient_GetNodeStatus_Call {
	_c.Call.Return(nodeStatus, err)
	return _c
}

func (_c *MockLNClient_GetNodeStatus_Call) RunAndReturn(run func(context.Context) (*lnclient.NodeStatus, error)) *MockLNClient_GetNodeStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetOnchainBalance provides a mock function with given fields: ctx
func (_m *MockLNClient) GetOnchainBalance(ctx context.Context) (*lnclient.OnchainBalanceResponse, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetOnchainBalance")
	}

	var r0 *lnclient.OnchainBalanceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*lnclient.OnchainBalanceResponse, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *lnclient.OnchainBalanceResponse); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.OnchainBalanceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_GetOnchainBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOnchainBalance'
type MockLNClient_GetOnchainBalance_Call struct {
	*mock.Call
}

// GetOnchainBalance is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockLNClient_Expecter) GetOnchainBalance(ctx interface{}) *MockLNClient_GetOnchainBalance_Call {
	return &MockLNClient_GetOnchainBalance_Call{Call: _e.mock.On("GetOnchainBalance", ctx)}
}

func (_c *MockLNClient_GetOnchainBalance_Call) Run(run func(ctx context.Context)) *MockLNClient_GetOnchainBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLNClient_GetOnchainBalance_Call) Return(_a0 *lnclient.OnchainBalanceResponse, _a1 error) *MockLNClient_GetOnchainBalance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLNClient_GetOnchainBalance_Call) RunAndReturn(run func(context.Context) (*lnclient.OnchainBalanceResponse, error)) *MockLNClient_GetOnchainBalance_Call {
	_c.Call.Return(run)
	return _c
}

// GetPubkey provides a mock function with no fields
func (_m *MockLNClient) GetPubkey() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetPubkey")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockLNClient_GetPubkey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPubkey'
type MockLNClient_GetPubkey_Call struct {
	*mock.Call
}

// GetPubkey is a helper method to define mock.On call
func (_e *MockLNClient_Expecter) GetPubkey() *MockLNClient_GetPubkey_Call {
	return &MockLNClient_GetPubkey_Call{Call: _e.mock.On("GetPubkey")}
}

func (_c *MockLNClient_GetPubkey_Call) Run(run func()) *MockLNClient_GetPubkey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLNClient_GetPubkey_Call) Return(_a0 string) *MockLNClient_GetPubkey_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLNClient_GetPubkey_Call) RunAndReturn(run func() string) *MockLNClient_GetPubkey_Call {
	_c.Call.Return(run)
	return _c
}

// GetStorageDir provides a mock function with no fields
func (_m *MockLNClient) GetStorageDir() (string, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetStorageDir")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func() (string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_GetStorageDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetStorageDir'
type MockLNClient_GetStorageDir_Call struct {
	*mock.Call
}

// GetStorageDir is a helper method to define mock.On call
func (_e *MockLNClient_Expecter) GetStorageDir() *MockLNClient_GetStorageDir_Call {
	return &MockLNClient_GetStorageDir_Call{Call: _e.mock.On("GetStorageDir")}
}

func (_c *MockLNClient_GetStorageDir_Call) Run(run func()) *MockLNClient_GetStorageDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLNClient_GetStorageDir_Call) Return(_a0 string, _a1 error) *MockLNClient_GetStorageDir_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLNClient_GetStorageDir_Call) RunAndReturn(run func() (string, error)) *MockLNClient_GetStorageDir_Call {
	_c.Call.Return(run)
	return _c
}

// GetSupportedNIP47Methods provides a mock function with no fields
func (_m *MockLNClient) GetSupportedNIP47Methods() []string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSupportedNIP47Methods")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// MockLNClient_GetSupportedNIP47Methods_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSupportedNIP47Methods'
type MockLNClient_GetSupportedNIP47Methods_Call struct {
	*mock.Call
}

// GetSupportedNIP47Methods is a helper method to define mock.On call
func (_e *MockLNClient_Expecter) GetSupportedNIP47Methods() *MockLNClient_GetSupportedNIP47Methods_Call {
	return &MockLNClient_GetSupportedNIP47Methods_Call{Call: _e.mock.On("GetSupportedNIP47Methods")}
}

func (_c *MockLNClient_GetSupportedNIP47Methods_Call) Run(run func()) *MockLNClient_GetSupportedNIP47Methods_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLNClient_GetSupportedNIP47Methods_Call) Return(_a0 []string) *MockLNClient_GetSupportedNIP47Methods_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLNClient_GetSupportedNIP47Methods_Call) RunAndReturn(run func() []string) *MockLNClient_GetSupportedNIP47Methods_Call {
	_c.Call.Return(run)
	return _c
}

// GetSupportedNIP47NotificationTypes provides a mock function with no fields
func (_m *MockLNClient) GetSupportedNIP47NotificationTypes() []string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSupportedNIP47NotificationTypes")
	}

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// MockLNClient_GetSupportedNIP47NotificationTypes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSupportedNIP47NotificationTypes'
type MockLNClient_GetSupportedNIP47NotificationTypes_Call struct {
	*mock.Call
}

// GetSupportedNIP47NotificationTypes is a helper method to define mock.On call
func (_e *MockLNClient_Expecter) GetSupportedNIP47NotificationTypes() *MockLNClient_GetSupportedNIP47NotificationTypes_Call {
	return &MockLNClient_GetSupportedNIP47NotificationTypes_Call{Call: _e.mock.On("GetSupportedNIP47NotificationTypes")}
}

func (_c *MockLNClient_GetSupportedNIP47NotificationTypes_Call) Run(run func()) *MockLNClient_GetSupportedNIP47NotificationTypes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLNClient_GetSupportedNIP47NotificationTypes_Call) Return(_a0 []string) *MockLNClient_GetSupportedNIP47NotificationTypes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLNClient_GetSupportedNIP47NotificationTypes_Call) RunAndReturn(run func() []string) *MockLNClient_GetSupportedNIP47NotificationTypes_Call {
	_c.Call.Return(run)
	return _c
}

// ListChannels provides a mock function with given fields: ctx
func (_m *MockLNClient) ListChannels(ctx context.Context) ([]lnclient.Channel, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListChannels")
	}

	var r0 []lnclient.Channel
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]lnclient.Channel, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []lnclient.Channel); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]lnclient.Channel)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_ListChannels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListChannels'
type MockLNClient_ListChannels_Call struct {
	*mock.Call
}

// ListChannels is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockLNClient_Expecter) ListChannels(ctx interface{}) *MockLNClient_ListChannels_Call {
	return &MockLNClient_ListChannels_Call{Call: _e.mock.On("ListChannels", ctx)}
}

func (_c *MockLNClient_ListChannels_Call) Run(run func(ctx context.Context)) *MockLNClient_ListChannels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLNClient_ListChannels_Call) Return(channels []lnclient.Channel, err error) *MockLNClient_ListChannels_Call {
	_c.Call.Return(channels, err)
	return _c
}

func (_c *MockLNClient_ListChannels_Call) RunAndReturn(run func(context.Context) ([]lnclient.Channel, error)) *MockLNClient_ListChannels_Call {
	_c.Call.Return(run)
	return _c
}

// ListPeers provides a mock function with given fields: ctx
func (_m *MockLNClient) ListPeers(ctx context.Context) ([]lnclient.PeerDetails, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListPeers")
	}

	var r0 []lnclient.PeerDetails
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]lnclient.PeerDetails, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []lnclient.PeerDetails); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]lnclient.PeerDetails)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_ListPeers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPeers'
type MockLNClient_ListPeers_Call struct {
	*mock.Call
}

// ListPeers is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockLNClient_Expecter) ListPeers(ctx interface{}) *MockLNClient_ListPeers_Call {
	return &MockLNClient_ListPeers_Call{Call: _e.mock.On("ListPeers", ctx)}
}

func (_c *MockLNClient_ListPeers_Call) Run(run func(ctx context.Context)) *MockLNClient_ListPeers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockLNClient_ListPeers_Call) Return(_a0 []lnclient.PeerDetails, _a1 error) *MockLNClient_ListPeers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLNClient_ListPeers_Call) RunAndReturn(run func(context.Context) ([]lnclient.PeerDetails, error)) *MockLNClient_ListPeers_Call {
	_c.Call.Return(run)
	return _c
}

// ListTransactions provides a mock function with given fields: ctx, from, until, limit, offset, unpaid, invoiceType
func (_m *MockLNClient) ListTransactions(ctx context.Context, from uint64, until uint64, limit uint64, offset uint64, unpaid bool, invoiceType string) ([]lnclient.Transaction, error) {
	ret := _m.Called(ctx, from, until, limit, offset, unpaid, invoiceType)

	if len(ret) == 0 {
		panic("no return value specified for ListTransactions")
	}

	var r0 []lnclient.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, uint64, uint64, bool, string) ([]lnclient.Transaction, error)); ok {
		return rf(ctx, from, until, limit, offset, unpaid, invoiceType)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, uint64, uint64, uint64, bool, string) []lnclient.Transaction); ok {
		r0 = rf(ctx, from, until, limit, offset, unpaid, invoiceType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]lnclient.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, uint64, uint64, uint64, bool, string) error); ok {
		r1 = rf(ctx, from, until, limit, offset, unpaid, invoiceType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_ListTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTransactions'
type MockLNClient_ListTransactions_Call struct {
	*mock.Call
}

// ListTransactions is a helper method to define mock.On call
//   - ctx context.Context
//   - from uint64
//   - until uint64
//   - limit uint64
//   - offset uint64
//   - unpaid bool
//   - invoiceType string
func (_e *MockLNClient_Expecter) ListTransactions(ctx interface{}, from interface{}, until interface{}, limit interface{}, offset interface{}, unpaid interface{}, invoiceType interface{}) *MockLNClient_ListTransactions_Call {
	return &MockLNClient_ListTransactions_Call{Call: _e.mock.On("ListTransactions", ctx, from, until, limit, offset, unpaid, invoiceType)}
}

func (_c *MockLNClient_ListTransactions_Call) Run(run func(ctx context.Context, from uint64, until uint64, limit uint64, offset uint64, unpaid bool, invoiceType string)) *MockLNClient_ListTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(uint64), args[3].(uint64), args[4].(uint64), args[5].(bool), args[6].(string))
	})
	return _c
}

func (_c *MockLNClient_ListTransactions_Call) Return(transactions []lnclient.Transaction, err error) *MockLNClient_ListTransactions_Call {
	_c.Call.Return(transactions, err)
	return _c
}

func (_c *MockLNClient_ListTransactions_Call) RunAndReturn(run func(context.Context, uint64, uint64, uint64, uint64, bool, string) ([]lnclient.Transaction, error)) *MockLNClient_ListTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// LookupInvoice provides a mock function with given fields: ctx, paymentHash
func (_m *MockLNClient) LookupInvoice(ctx context.Context, paymentHash string) (*lnclient.Transaction, error) {
	ret := _m.Called(ctx, paymentHash)

	if len(ret) == 0 {
		panic("no return value specified for LookupInvoice")
	}

	var r0 *lnclient.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*lnclient.Transaction, error)); ok {
		return rf(ctx, paymentHash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *lnclient.Transaction); ok {
		r0 = rf(ctx, paymentHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, paymentHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_LookupInvoice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LookupInvoice'
type MockLNClient_LookupInvoice_Call struct {
	*mock.Call
}

// LookupInvoice is a helper method to define mock.On call
//   - ctx context.Context
//   - paymentHash string
func (_e *MockLNClient_Expecter) LookupInvoice(ctx interface{}, paymentHash interface{}) *MockLNClient_LookupInvoice_Call {
	return &MockLNClient_LookupInvoice_Call{Call: _e.mock.On("LookupInvoice", ctx, paymentHash)}
}

func (_c *MockLNClient_LookupInvoice_Call) Run(run func(ctx context.Context, paymentHash string)) *MockLNClient_LookupInvoice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLNClient_LookupInvoice_Call) Return(transaction *lnclient.Transaction, err error) *MockLNClient_LookupInvoice_Call {
	_c.Call.Return(transaction, err)
	return _c
}

func (_c *MockLNClient_LookupInvoice_Call) RunAndReturn(run func(context.Context, string) (*lnclient.Transaction, error)) *MockLNClient_LookupInvoice_Call {
	_c.Call.Return(run)
	return _c
}

// MakeInvoice provides a mock function with given fields: ctx, amount, description, descriptionHash, expiry
func (_m *MockLNClient) MakeInvoice(ctx context.Context, amount int64, description string, descriptionHash string, expiry int64) (*lnclient.Transaction, error) {
	ret := _m.Called(ctx, amount, description, descriptionHash, expiry)

	if len(ret) == 0 {
		panic("no return value specified for MakeInvoice")
	}

	var r0 *lnclient.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, string, int64) (*lnclient.Transaction, error)); ok {
		return rf(ctx, amount, description, descriptionHash, expiry)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, string, string, int64) *lnclient.Transaction); ok {
		r0 = rf(ctx, amount, description, descriptionHash, expiry)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, string, string, int64) error); ok {
		r1 = rf(ctx, amount, description, descriptionHash, expiry)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_MakeInvoice_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MakeInvoice'
type MockLNClient_MakeInvoice_Call struct {
	*mock.Call
}

// MakeInvoice is a helper method to define mock.On call
//   - ctx context.Context
//   - amount int64
//   - description string
//   - descriptionHash string
//   - expiry int64
func (_e *MockLNClient_Expecter) MakeInvoice(ctx interface{}, amount interface{}, description interface{}, descriptionHash interface{}, expiry interface{}) *MockLNClient_MakeInvoice_Call {
	return &MockLNClient_MakeInvoice_Call{Call: _e.mock.On("MakeInvoice", ctx, amount, description, descriptionHash, expiry)}
}

func (_c *MockLNClient_MakeInvoice_Call) Run(run func(ctx context.Context, amount int64, description string, descriptionHash string, expiry int64)) *MockLNClient_MakeInvoice_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(string), args[3].(string), args[4].(int64))
	})
	return _c
}

func (_c *MockLNClient_MakeInvoice_Call) Return(transaction *lnclient.Transaction, err error) *MockLNClient_MakeInvoice_Call {
	_c.Call.Return(transaction, err)
	return _c
}

func (_c *MockLNClient_MakeInvoice_Call) RunAndReturn(run func(context.Context, int64, string, string, int64) (*lnclient.Transaction, error)) *MockLNClient_MakeInvoice_Call {
	_c.Call.Return(run)
	return _c
}

// OpenChannel provides a mock function with given fields: ctx, openChannelRequest
func (_m *MockLNClient) OpenChannel(ctx context.Context, openChannelRequest *lnclient.OpenChannelRequest) (*lnclient.OpenChannelResponse, error) {
	ret := _m.Called(ctx, openChannelRequest)

	if len(ret) == 0 {
		panic("no return value specified for OpenChannel")
	}

	var r0 *lnclient.OpenChannelResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnclient.OpenChannelRequest) (*lnclient.OpenChannelResponse, error)); ok {
		return rf(ctx, openChannelRequest)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnclient.OpenChannelRequest) *lnclient.OpenChannelResponse); ok {
		r0 = rf(ctx, openChannelRequest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.OpenChannelResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnclient.OpenChannelRequest) error); ok {
		r1 = rf(ctx, openChannelRequest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_OpenChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OpenChannel'
type MockLNClient_OpenChannel_Call struct {
	*mock.Call
}

// OpenChannel is a helper method to define mock.On call
//   - ctx context.Context
//   - openChannelRequest *lnclient.OpenChannelRequest
func (_e *MockLNClient_Expecter) OpenChannel(ctx interface{}, openChannelRequest interface{}) *MockLNClient_OpenChannel_Call {
	return &MockLNClient_OpenChannel_Call{Call: _e.mock.On("OpenChannel", ctx, openChannelRequest)}
}

func (_c *MockLNClient_OpenChannel_Call) Run(run func(ctx context.Context, openChannelRequest *lnclient.OpenChannelRequest)) *MockLNClient_OpenChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*lnclient.OpenChannelRequest))
	})
	return _c
}

func (_c *MockLNClient_OpenChannel_Call) Return(_a0 *lnclient.OpenChannelResponse, _a1 error) *MockLNClient_OpenChannel_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLNClient_OpenChannel_Call) RunAndReturn(run func(context.Context, *lnclient.OpenChannelRequest) (*lnclient.OpenChannelResponse, error)) *MockLNClient_OpenChannel_Call {
	_c.Call.Return(run)
	return _c
}

// RedeemOnchainFunds provides a mock function with given fields: ctx, toAddress, amount, sendAll
func (_m *MockLNClient) RedeemOnchainFunds(ctx context.Context, toAddress string, amount uint64, sendAll bool) (string, error) {
	ret := _m.Called(ctx, toAddress, amount, sendAll)

	if len(ret) == 0 {
		panic("no return value specified for RedeemOnchainFunds")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, bool) (string, error)); ok {
		return rf(ctx, toAddress, amount, sendAll)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, bool) string); ok {
		r0 = rf(ctx, toAddress, amount, sendAll)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, uint64, bool) error); ok {
		r1 = rf(ctx, toAddress, amount, sendAll)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_RedeemOnchainFunds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RedeemOnchainFunds'
type MockLNClient_RedeemOnchainFunds_Call struct {
	*mock.Call
}

// RedeemOnchainFunds is a helper method to define mock.On call
//   - ctx context.Context
//   - toAddress string
//   - amount uint64
//   - sendAll bool
func (_e *MockLNClient_Expecter) RedeemOnchainFunds(ctx interface{}, toAddress interface{}, amount interface{}, sendAll interface{}) *MockLNClient_RedeemOnchainFunds_Call {
	return &MockLNClient_RedeemOnchainFunds_Call{Call: _e.mock.On("RedeemOnchainFunds", ctx, toAddress, amount, sendAll)}
}

func (_c *MockLNClient_RedeemOnchainFunds_Call) Run(run func(ctx context.Context, toAddress string, amount uint64, sendAll bool)) *MockLNClient_RedeemOnchainFunds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64), args[3].(bool))
	})
	return _c
}

func (_c *MockLNClient_RedeemOnchainFunds_Call) Return(txId string, err error) *MockLNClient_RedeemOnchainFunds_Call {
	_c.Call.Return(txId, err)
	return _c
}

func (_c *MockLNClient_RedeemOnchainFunds_Call) RunAndReturn(run func(context.Context, string, uint64, bool) (string, error)) *MockLNClient_RedeemOnchainFunds_Call {
	_c.Call.Return(run)
	return _c
}

// ResetRouter provides a mock function with given fields: key
func (_m *MockLNClient) ResetRouter(key string) error {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for ResetRouter")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLNClient_ResetRouter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetRouter'
type MockLNClient_ResetRouter_Call struct {
	*mock.Call
}

// ResetRouter is a helper method to define mock.On call
//   - key string
func (_e *MockLNClient_Expecter) ResetRouter(key interface{}) *MockLNClient_ResetRouter_Call {
	return &MockLNClient_ResetRouter_Call{Call: _e.mock.On("ResetRouter", key)}
}

func (_c *MockLNClient_ResetRouter_Call) Run(run func(key string)) *MockLNClient_ResetRouter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockLNClient_ResetRouter_Call) Return(_a0 error) *MockLNClient_ResetRouter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLNClient_ResetRouter_Call) RunAndReturn(run func(string) error) *MockLNClient_ResetRouter_Call {
	_c.Call.Return(run)
	return _c
}

// SendKeysend provides a mock function with given fields: ctx, amount, destination, customRecords, preimage
func (_m *MockLNClient) SendKeysend(ctx context.Context, amount uint64, destination string, customRecords []lnclient.TLVRecord, preimage string) (*lnclient.PayKeysendResponse, error) {
	ret := _m.Called(ctx, amount, destination, customRecords, preimage)

	if len(ret) == 0 {
		panic("no return value specified for SendKeysend")
	}

	var r0 *lnclient.PayKeysendResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, string, []lnclient.TLVRecord, string) (*lnclient.PayKeysendResponse, error)); ok {
		return rf(ctx, amount, destination, customRecords, preimage)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64, string, []lnclient.TLVRecord, string) *lnclient.PayKeysendResponse); ok {
		r0 = rf(ctx, amount, destination, customRecords, preimage)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.PayKeysendResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64, string, []lnclient.TLVRecord, string) error); ok {
		r1 = rf(ctx, amount, destination, customRecords, preimage)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_SendKeysend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendKeysend'
type MockLNClient_SendKeysend_Call struct {
	*mock.Call
}

// SendKeysend is a helper method to define mock.On call
//   - ctx context.Context
//   - amount uint64
//   - destination string
//   - customRecords []lnclient.TLVRecord
//   - preimage string
func (_e *MockLNClient_Expecter) SendKeysend(ctx interface{}, amount interface{}, destination interface{}, customRecords interface{}, preimage interface{}) *MockLNClient_SendKeysend_Call {
	return &MockLNClient_SendKeysend_Call{Call: _e.mock.On("SendKeysend", ctx, amount, destination, customRecords, preimage)}
}

func (_c *MockLNClient_SendKeysend_Call) Run(run func(ctx context.Context, amount uint64, destination string, customRecords []lnclient.TLVRecord, preimage string)) *MockLNClient_SendKeysend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(string), args[3].([]lnclient.TLVRecord), args[4].(string))
	})
	return _c
}

func (_c *MockLNClient_SendKeysend_Call) Return(_a0 *lnclient.PayKeysendResponse, _a1 error) *MockLNClient_SendKeysend_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLNClient_SendKeysend_Call) RunAndReturn(run func(context.Context, uint64, string, []lnclient.TLVRecord, string) (*lnclient.PayKeysendResponse, error)) *MockLNClient_SendKeysend_Call {
	_c.Call.Return(run)
	return _c
}

// SendPaymentProbes provides a mock function with given fields: ctx, invoice
func (_m *MockLNClient) SendPaymentProbes(ctx context.Context, invoice string) error {
	ret := _m.Called(ctx, invoice)

	if len(ret) == 0 {
		panic("no return value specified for SendPaymentProbes")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, invoice)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLNClient_SendPaymentProbes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendPaymentProbes'
type MockLNClient_SendPaymentProbes_Call struct {
	*mock.Call
}

// SendPaymentProbes is a helper method to define mock.On call
//   - ctx context.Context
//   - invoice string
func (_e *MockLNClient_Expecter) SendPaymentProbes(ctx interface{}, invoice interface{}) *MockLNClient_SendPaymentProbes_Call {
	return &MockLNClient_SendPaymentProbes_Call{Call: _e.mock.On("SendPaymentProbes", ctx, invoice)}
}

func (_c *MockLNClient_SendPaymentProbes_Call) Run(run func(ctx context.Context, invoice string)) *MockLNClient_SendPaymentProbes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLNClient_SendPaymentProbes_Call) Return(_a0 error) *MockLNClient_SendPaymentProbes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLNClient_SendPaymentProbes_Call) RunAndReturn(run func(context.Context, string) error) *MockLNClient_SendPaymentProbes_Call {
	_c.Call.Return(run)
	return _c
}

// SendPaymentSync provides a mock function with given fields: ctx, payReq, amount
func (_m *MockLNClient) SendPaymentSync(ctx context.Context, payReq string, amount *uint64) (*lnclient.PayInvoiceResponse, error) {
	ret := _m.Called(ctx, payReq, amount)

	if len(ret) == 0 {
		panic("no return value specified for SendPaymentSync")
	}

	var r0 *lnclient.PayInvoiceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *uint64) (*lnclient.PayInvoiceResponse, error)); ok {
		return rf(ctx, payReq, amount)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *uint64) *lnclient.PayInvoiceResponse); ok {
		r0 = rf(ctx, payReq, amount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnclient.PayInvoiceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *uint64) error); ok {
		r1 = rf(ctx, payReq, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_SendPaymentSync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendPaymentSync'
type MockLNClient_SendPaymentSync_Call struct {
	*mock.Call
}

// SendPaymentSync is a helper method to define mock.On call
//   - ctx context.Context
//   - payReq string
//   - amount *uint64
func (_e *MockLNClient_Expecter) SendPaymentSync(ctx interface{}, payReq interface{}, amount interface{}) *MockLNClient_SendPaymentSync_Call {
	return &MockLNClient_SendPaymentSync_Call{Call: _e.mock.On("SendPaymentSync", ctx, payReq, amount)}
}

func (_c *MockLNClient_SendPaymentSync_Call) Run(run func(ctx context.Context, payReq string, amount *uint64)) *MockLNClient_SendPaymentSync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*uint64))
	})
	return _c
}

func (_c *MockLNClient_SendPaymentSync_Call) Return(_a0 *lnclient.PayInvoiceResponse, _a1 error) *MockLNClient_SendPaymentSync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLNClient_SendPaymentSync_Call) RunAndReturn(run func(context.Context, string, *uint64) (*lnclient.PayInvoiceResponse, error)) *MockLNClient_SendPaymentSync_Call {
	_c.Call.Return(run)
	return _c
}

// SendSpontaneousPaymentProbes provides a mock function with given fields: ctx, amountMsat, nodeId
func (_m *MockLNClient) SendSpontaneousPaymentProbes(ctx context.Context, amountMsat uint64, nodeId string) error {
	ret := _m.Called(ctx, amountMsat, nodeId)

	if len(ret) == 0 {
		panic("no return value specified for SendSpontaneousPaymentProbes")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64, string) error); ok {
		r0 = rf(ctx, amountMsat, nodeId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLNClient_SendSpontaneousPaymentProbes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendSpontaneousPaymentProbes'
type MockLNClient_SendSpontaneousPaymentProbes_Call struct {
	*mock.Call
}

// SendSpontaneousPaymentProbes is a helper method to define mock.On call
//   - ctx context.Context
//   - amountMsat uint64
//   - nodeId string
func (_e *MockLNClient_Expecter) SendSpontaneousPaymentProbes(ctx interface{}, amountMsat interface{}, nodeId interface{}) *MockLNClient_SendSpontaneousPaymentProbes_Call {
	return &MockLNClient_SendSpontaneousPaymentProbes_Call{Call: _e.mock.On("SendSpontaneousPaymentProbes", ctx, amountMsat, nodeId)}
}

func (_c *MockLNClient_SendSpontaneousPaymentProbes_Call) Run(run func(ctx context.Context, amountMsat uint64, nodeId string)) *MockLNClient_SendSpontaneousPaymentProbes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(string))
	})
	return _c
}

func (_c *MockLNClient_SendSpontaneousPaymentProbes_Call) Return(_a0 error) *MockLNClient_SendSpontaneousPaymentProbes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLNClient_SendSpontaneousPaymentProbes_Call) RunAndReturn(run func(context.Context, uint64, string) error) *MockLNClient_SendSpontaneousPaymentProbes_Call {
	_c.Call.Return(run)
	return _c
}

// Shutdown provides a mock function with no fields
func (_m *MockLNClient) Shutdown() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Shutdown")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLNClient_Shutdown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Shutdown'
type MockLNClient_Shutdown_Call struct {
	*mock.Call
}

// Shutdown is a helper method to define mock.On call
func (_e *MockLNClient_Expecter) Shutdown() *MockLNClient_Shutdown_Call {
	return &MockLNClient_Shutdown_Call{Call: _e.mock.On("Shutdown")}
}

func (_c *MockLNClient_Shutdown_Call) Run(run func()) *MockLNClient_Shutdown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLNClient_Shutdown_Call) Return(_a0 error) *MockLNClient_Shutdown_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLNClient_Shutdown_Call) RunAndReturn(run func() error) *MockLNClient_Shutdown_Call {
	_c.Call.Return(run)
	return _c
}

// SignMessage provides a mock function with given fields: ctx, message
func (_m *MockLNClient) SignMessage(ctx context.Context, message string) (string, error) {
	ret := _m.Called(ctx, message)

	if len(ret) == 0 {
		panic("no return value specified for SignMessage")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, message)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, message)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, message)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockLNClient_SignMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignMessage'
type MockLNClient_SignMessage_Call struct {
	*mock.Call
}

// SignMessage is a helper method to define mock.On call
//   - ctx context.Context
//   - message string
func (_e *MockLNClient_Expecter) SignMessage(ctx interface{}, message interface{}) *MockLNClient_SignMessage_Call {
	return &MockLNClient_SignMessage_Call{Call: _e.mock.On("SignMessage", ctx, message)}
}

func (_c *MockLNClient_SignMessage_Call) Run(run func(ctx context.Context, message string)) *MockLNClient_SignMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockLNClient_SignMessage_Call) Return(_a0 string, _a1 error) *MockLNClient_SignMessage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockLNClient_SignMessage_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockLNClient_SignMessage_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateChannel provides a mock function with given fields: ctx, updateChannelRequest
func (_m *MockLNClient) UpdateChannel(ctx context.Context, updateChannelRequest *lnclient.UpdateChannelRequest) error {
	ret := _m.Called(ctx, updateChannelRequest)

	if len(ret) == 0 {
		panic("no return value specified for UpdateChannel")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnclient.UpdateChannelRequest) error); ok {
		r0 = rf(ctx, updateChannelRequest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockLNClient_UpdateChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateChannel'
type MockLNClient_UpdateChannel_Call struct {
	*mock.Call
}

// UpdateChannel is a helper method to define mock.On call
//   - ctx context.Context
//   - updateChannelRequest *lnclient.UpdateChannelRequest
func (_e *MockLNClient_Expecter) UpdateChannel(ctx interface{}, updateChannelRequest interface{}) *MockLNClient_UpdateChannel_Call {
	return &MockLNClient_UpdateChannel_Call{Call: _e.mock.On("UpdateChannel", ctx, updateChannelRequest)}
}

func (_c *MockLNClient_UpdateChannel_Call) Run(run func(ctx context.Context, updateChannelRequest *lnclient.UpdateChannelRequest)) *MockLNClient_UpdateChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*lnclient.UpdateChannelRequest))
	})
	return _c
}

func (_c *MockLNClient_UpdateChannel_Call) Return(_a0 error) *MockLNClient_UpdateChannel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockLNClient_UpdateChannel_Call) RunAndReturn(run func(context.Context, *lnclient.UpdateChannelRequest) error) *MockLNClient_UpdateChannel_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateLastWalletSyncRequest provides a mock function with no fields
func (_m *MockLNClient) UpdateLastWalletSyncRequest() {
	_m.Called()
}

// MockLNClient_UpdateLastWalletSyncRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateLastWalletSyncRequest'
type MockLNClient_UpdateLastWalletSyncRequest_Call struct {
	*mock.Call
}

// UpdateLastWalletSyncRequest is a helper method to define mock.On call
func (_e *MockLNClient_Expecter) UpdateLastWalletSyncRequest() *MockLNClient_UpdateLastWalletSyncRequest_Call {
	return &MockLNClient_UpdateLastWalletSyncRequest_Call{Call: _e.mock.On("UpdateLastWalletSyncRequest")}
}

func (_c *MockLNClient_UpdateLastWalletSyncRequest_Call) Run(run func()) *MockLNClient_UpdateLastWalletSyncRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLNClient_UpdateLastWalletSyncRequest_Call) Return() *MockLNClient_UpdateLastWalletSyncRequest_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockLNClient_UpdateLastWalletSyncRequest_Call) RunAndReturn(run func()) *MockLNClient_UpdateLastWalletSyncRequest_Call {
	_c.Run(run)
	return _c
}

// NewMockLNClient creates a new instance of MockLNClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLNClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLNClient {
	mock := &MockLNClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
